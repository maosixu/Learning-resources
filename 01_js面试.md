# 第一章JS变量

## var、let、const的差异

面试高频指数：★★★★★

### 相同点

`var`、`let`、`const` 三者都可以声明变量。变量可以看作盒子，变量名就是盒子名称，值是放在盒子里的东西。

```js
// var 声明变量，初始值可选
var name;
var name = "Lucy";

// let 声明变量，初始值可选
let age;
let age = 12;

// const 声明常量，必须要赋初始值
const city = "Beijing";
// 如果给常量重新赋值会报错
const city = "Shanghai"; // Uncaught SyntaxError: Identifier 'city' has already been declared

// 如果常量的值是对象（数组），不可以修改常量指向的引用，但是可以修改引用的值
const cities = ["Beijing"];
cities[0] = ["Shanghai"]; // "Shanghai"
```

### 差异

var、let、const三者的差异：

|       | 定义                | 作用域     | 暂时性死区 | 重复声明变量 | 全局属性 |
| ----- | ------------------- | ---------- | ---------- | ------------ | -------- |
| const | 声明常量            | 块级作用域 | ✅          | ❎            | ❎        |
| let   | 声明变量（ES6新增） | 块级作用域 | ✅          | ❎            | ❎        |
| var   | 声明变量            | 函数作用域 | ❎          | ✅            | ✅        |

### 暂时性死区

从一个代码块的开始直到代码执行到声明变量的行之前，let 或 const 声明的变量都处于“暂时性死区中。简单理解：`let 或 const 只能先声明再访问`。

### 全局属性

在函数体外使用`var` 声明，则会声明一个**全局变量**，该变量被实现为全局对象的属性。可以使用 `window `和 `globalThis` 访问，`let` 和 `const` 声明的全局变量则不会添加到全局对象中。

```js
var name = "Lucy";
console.log(window.name); // "Lucy"
console.log(globalThis.name); // "Lucy"

const age = 12;
console.log(window.age); // undefined
console.log(globalThis.age); // undefined

let gender = "female";
console.log(window.gender); // undefined
console.log(globalThis.gender); // undefined
```

> 通过var声明的全局属性不能通过delete操作符删除

## 作用域

面试高频指数：★★★★★

**作用域**是当前的执行上下文，[值](https://developer.mozilla.org/zh-CN/docs/Glossary/Value)和表达式在其中“可见”或可被访问。如果一个[变量](https://developer.mozilla.org/zh-CN/docs/Glossary/Variable)或表达式不在当前的作用域中，那么它是不可用的。作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。

JavaScript 的作用域分以下三种：

- **全局作用域**：脚本模式运行所有代码的默认作用域
- **模块作用域**：模块模式中运行代码的作用域
- **函数作用域**：由[函数](https://developer.mozilla.org/zh-CN/docs/Glossary/Function)创建的作用域

此外，用 [`let`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let) 或 [`const`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const) 声明的变量属于额外的作用域：

- **块级作用域**：用一对花括号（一个[代码块](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/block)）创建出来的作用域

```js
{ 
    // 作用域 A，可以访问变量 x
    const x = 0; 
    console.log(x); // 0
    {
        // 作用域 B，可以访问 x、y
        const y  = 1;
        console.log(x); // 0
        console.log(y); // 1
    }
}
// 作用域 A 外，不能访问 x、y
console.log(x); // 报错：Uncaught ReferenceError: x is not defined
```

同一作用域内，不允许声明同名变量。如下示例代码用 const 声明同名变量：

```js
{
    const x = 1;
    const x = 2; // 报错：Uncaught SyntaxError: Identifier 'x' has already been declared
}
```

不同作用域下可以使用同名变量：

```js
{
    const x = 1;
    {
        const x = 2; 
    }
}
```

### 静态作用域和动态作用域

* 作用域分为**静态作用域**（又称为词法作用域）和**动态作用域**：
  * 静态意味着它与原代码的位置有关，与执行代码时的环境无关
    变量作用域是静态作用域

* 动态即运行时，代码执行时确定的
  * 函数调用就是动态的

* 在 JavaScript 中，作用域是在代码编写阶段确定的，而不是在代码执行阶段确定的。JavaScript 使用**词法作用域规则**来确定变量的作用域。

  根据词法作用域规则，一个变量的作用域是由其在代码中的位置决定的，与函数被调用的位置无关。当在函数内部访问一个变量时，会首先在当前函数内部查找，如果找不到则向上一级的作用域中查找，直到找到该变量或抵达全局作用域。

```js
function g(x) {}
function h(y) {
    if (Math.random()) g(y); // 此处作用域的形成决定于运行时
}
```

### 全局变量和全局对象

JavaScript 变量作用域是嵌套的，它们形成树：

* 最外面的作用域是树的根部，也叫**全局作用域**。
* 被最外层作用域包含的作用域是根的子孙，如各种嵌套的代码块形成的作用域。

全局作用域中的变量称为全局变量，可以在任何作用域内访问。有两种全局变量：

* 全局声明变量（declarative variables）是普通变量，在最顶级由 const、let 和 class 声明的
* 全局对象（object variables）是存储在全局对象中的属性：
  * 在最顶级由 var 和 function 声明后创建的变量
  * 全局对象可以通过 `globalThis `和 `window `访问，它可以对全局对象变量进行增删改查

全局属性` globalThis `包含全局的 `this `值，类似于全局对象。`globalThis` 提供了一个标准的方式来**获取不同环境下的全局` this `对象**（也就是全局对象自身），它可以在任何环境下使用。

下面的代码可以帮助我们更好理解 globalThis 和两种全局变量：
```js
<script>
const declarativeVariable = 'd';
var objectVariable = 'o';
</script>

<script>
// 所有脚本共享同样的顶级作用域
console.log(declarativeVariable); // 'd'
console.log(objectVariable); // 'o'

// 不是所有变量都会创建为全局对象的属性
console.log(globalThis.declarativeVariable); // undefined  
console.log(globalThis.objectVariable); // 'o'
</script>
```

每个 ECMAScript 模块（ES6 Modules）都有自己的作用域，因此，在顶级模块中声明的变量不是全局的。如下图所示：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675243681-ITEQCA-image.png)

### 总结：各种声明的异同

我们从以下四个方面来看各种声明的异同：

* **作用域**
* **暂时性死区**：变量何时可以访问？一些变量在进入作用域后可尽快被访问，但有的必须等到代码执行到它们声明时才可以访问。通俗说法是，这个变量是否可以先访问再声明。暂时性死区就是变量在进入作用域和执行声明前的一段时间。在这段时间内，访问变量会报错。
* **重复声明**：变量是否可以重复声明（同级作用域下）
* **全局属性**：声明的变量是否会被添加到全局对象中

|          | 作用域               | 暂时性死区 | 重复声明 | 全局属性 |
| -------- | -------------------- | ---------- | -------- | -------- |
| const    | 块级作用域           | ✅          | ❎        | ❎        |
| let      | 块级作用域           | ✅          | ❎        | ❎        |
| class    | 块级作用域           | ✅          | ❎        | ❎        |
| function | 块级作用域           | ❎          | ✅        | ✅        |
| var      | 函数作用域（函数内） | ❎          | ✅        | ✅        |

在 JavaScript 中，**函数作用域**和**块级作用域**是两种不同的作用域类型。

**函数作用域**是指函数内部声明的变量只能在函数内部访问。这意味着在函数外部无法访问函数内部的变量，这些变量被称为**局部变量**。

> 函数作用域可以避免变量污染全局作用域，同时可以将变量封装在函数内部，提高代码的可读性和可维护性。 

**块级作用域**是指在代码块内声明的变量只能在该代码块内访问。在 JavaScript 中，代码块通常由花括号 `{}` 包围，例如 `if`、`for`、`while` 语句等。在 ES6 中，通过 `let` 和 `const` 关键字可以在块级作用域中声明变量，这种变量被称为块级作用域变量。

> 块级作用域可以避免变量污染全局作用域，同时可以提高代码的可读性和可维护性。

例子：

函数作用域：
```js
function exampleFunction() {
  var x = 1; // x在这个函数内部是可见的
  console.log(x); // 1
}
console.log(x); // ReferenceError: x is not defined
```

块级作用域：

```js
if (true) {
  var x = 1; // 变量提升，x在代码块外部也可以访问
  let y = 2; // y只在代码块内部可见
  const z = 3; // z只在代码块内部可见
}
console.log(x); // 1
console.log(y); // ReferenceError: y is not defined
console.log(z); // ReferenceError: z is not defined
```

在ES6中，可以使用`let`和`const`关键字来声明块级作用域的变量：

```js
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 在每个迭代中输出正确的值
  }, 1000);
}
```

在以上示例中，使用`let`声明的`i`仅在for循环块中可见，因此`setTimeout`回调函数可以在每个迭代中输出正确的值。

## 变量提升

面试高频指数：★★★★★

当 JavaScript 引擎执行代码时，创建了全局执行上下文，它有两个阶段：

* 创建（准备工作）
* 执行

在创建阶段，JavaScript 引擎将 var 和 function 声明移到了顶层，这就是 JavaScript 的变量提升。

### var关键字

```js
console.log(counter); // undefined
var counter = 1;
```

我们在声明前访问 `counter` 变量，并未报错。这是变量提升的缘故。

### function提升

和 `var` 一样，函数声明也会提升：
```js
let x = 20,
	y = 10;

let result = add(x, y);
console.log(result); // 30

function add(a, b) {
	return a + b;
}
```

> 除此之外，`let` 关键字、函数表达式、箭头函数等均不会变量提升。

### 处理相同的变量名或者函数名

代码中出现同名的变量名或者函数名，都是后者覆盖前者。

# 第二章JS数据类型

## JS数据类型

面试高频指数：★★★★★

JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始数据类型，后一种 Object 为复杂数据类型，也称为非原始数据类型或引用类型）。

* 原始数据类型：
  * `number`用于任何类型的数字：整数或浮点数，在`±(2(^53)-1)` 范围内的整数。
  * `bigint`任意精度的整数
  * `string`用于字符串：一个字符串可以包含0个或多个字符，所以没有单独的字符类型。
  * `boolean`有`true`和`false`两种值
  * `null`用于未知的值——只有一个`null`值的独立类型
  * `undefined`用于未定义的值——只有一个`undefined`值的独立类型
  * `symbol`用于唯一的标识符
* 以及一种非原始数据类型：
  * `Object`用于更复杂的数据结构。以下类型都是对象：
    * Function（函数）
    * Array（数组）
    * Date（日期）
    * RegExp（正则表达式）

## 原始数据类型和引用数据类型

面试高频指数：★★★★☆

JavaScript 包含两种不同类型的值：

- 原始数据类型（Primitive values）
- 引用数据类型（Reference values）

### 栈内存和堆内存

当定义一个变量的时候，JavaScript 引擎会为变量分配两种内存：栈内存和堆内存。

静态值在编译阶段有固定的大小，静态值有：

* 原始值：`Null`、`Undefined`、`Boolean`、`Number`、`String`、`Symbol`、`BigInt`
* 引用值：是对象的引用。

静态值有固定的大小，不能改变。JavaScript 引擎为它们分配一片固定的内存，并存储在栈上。例如：
```js
let name="Bob";
let age=25;
```

因为 `name` 和 `age` 都是原始值类型，JavaScript 引擎将它们存储在栈上，如下图所示：

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675246723-ulSguk-image.png)

JavaScript 将对象（`Object`) 存储在堆（heap）上。
```js
let person = {
    name: "John",
    age: 25
};
```

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675246788-HjXqny-image.png)

JavaScript 引擎在堆内存上创建了一个新的对象，同时它和栈内存上的 `person` 变量连接。因此，我们说 `person` 变量是对象的引用。

### 动态属性

一个引用值允许我们添加、修改和删除属性，例如：

```js
let person = {
    name: "John",
    age: 25
};

// 添加属性 ssn 
person.ssn = "123-45";

// 修改 name
person.name = "John Doe";

// 删除属性 age 
delete person.age;

console.log(person); // {name: 'John Doe', ssn: '123-45'}
```

JavaScript 也允许在原始值上添加属性，但这个属性不会起作用。

### 复制值

**原始值**

**对于原始值来说，JavaScript 引擎创建一个值的副本，并将值赋给新的变量。**

```js
let age = 25;
let newAge = age; 
console.log(age, newAge); // 25 25
```

过程如下：

* 首先，声明一个变量 age，并将 25 赋值给它。
* 其次，声明另一个新的变量 newAge，将 age 赋值给 newAge，JavaScript 引擎将 25 复制了一份，给了新变量。

如下图：

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675247356-DMFMSb-image.png)

因此，对两个变量的操作不会互相影响。

```js
let age = 25;
let newAge = age;

newAge = newAge + 1;
console.log(age, newAge); // 25 26
```

如下图：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675247413-GScWMN-image.png)

### 引用值

**对于引用值来说，复制的值指向的是同一个对象，因此操作的是也是同一个对象。**

当我们将一个引用值从一个变量赋值给另一个变量，JavaScript 引擎创建一个引用，因此两个变量都是指向堆内存中的同一个对象。意味着，你修改其中一个，另一个也会被修改。

```js
let person = {
    name: "John",
    age: 25
}

let member = person;
member.age = 26;

console.log(person); // {name: 'John', age: 26}
console.log(member); // {name: 'John', age: 26}
```

如下图所示：
修改前：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675247510-JurGlA-image.png)

修改后：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675247526-qFUHsM-image.png)

### 总结

* JavaScript 有两种类型的值：**原始值**和**引用值**
* 引用类型的值可以对它的属性做增删改查，原始值不行
* 从一个变量复制原始值到另一个变量，会创建一个独立的值的备份，意味着修改一个变量不会影响到另一个变量
* 从一个变量复制引用值到另一个变量，两个变量会指向同一个对象，意味着通过一个变量修改对象将会影响到另一个对象。

### 练习

判读以下代码的输出内容：
```js
let person = {
    name: "John",
    age: 25
}

function increaseAge(obj) {
    obj.age += 1;
    obj = {name: "Jame", age: 22}
    console.log(obj); // 1
}

increaseAge(person);
console.log(person); // 2
```

答案：1 处是：`{ name: "Jame", age: 22 }`， 2 处是 `{ name: 'John', age: 26 }`。两个变量的内存示意图如下：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675247879-Inlzhw-image.png)

实际上，` obj = {name: "Jame", age: 22} `使得 `obj `重新指向了一个新的引用的，对象在堆内存中重新分配一块内存，并让` obj `指向它。 因此 `console.log(person) `的结果是` { name: "Jame", age: 22 }`。

原始类型和引用类型在内存中的分配与函数参数传递有联系。函数传参都是值传递，只不过根据值的类型不同有所区别。

由上可知：

* JavaScript 实参都是传值
* 函数实参会在函数中创建新的局部变量

## 0.1+0.2！==0.3

面试高频指数：★★★★☆

```js
0.1+0.2===0.3  //false
```

因为JavaScript 采用“遵循 IEEE 754 标准的双精度 64 位格式”（"double-precision 64-bit format IEEE 754 values"）表示数字。

其具体格式为：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/787d2afcd4324c8bb21a76e324f80cba.png)

| 组成     | 描述                       | 位数  | 位置  |
| -------- | -------------------------- | ----- | ----- |
| sign     | 符号，0表示正数，1表示负数 | 1bit  | 63    |
| exponent | 指数部分                   | 11bit | 52-62 |
| fraction | 小数部分                   | 52bit | 0-51  |

**类型划分**

* 11位指数不为00000000000和11111111111，即在00000000001 ~11111111110范围内的值是规划值，而全0和全1为特殊数字保留。
* 指数值全0，称为非规格化
* 指数值全1，称为特殊值，有两种情况
  * 当52位小数为0且符号位为0是表示正无穷，若符号位为1表示负无穷。
  * 当52位小数不全为0，则表示NaN

**规格化**

规格化下的浮点数形式可表示为：

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1681224155323.png)

其中：

* `s`为0或1，0表示正数，1表示负数，对应1bit的符号位
* `f`为52位有效位，其中的每一位`b`是0或1，对应52bit的小数部分（不足52位补0）
* `c`是超出52位的部分（如果有的话，需要舍入（精度会丢失），规则下述）
* `e`为十进制数值，其11位的二进制数值对应11bit的指数部分
* `1023`为`移码`，移码值为 2^(n − 1) − 1，这里的n表示指数位数，对于64bit的双精度存储，n是11

> 十进制中，12345可表示为1.2345 × 10^4 二进制中，10011可表示为1.0011 × 2 ^4

有了以上知识后，我们来看：

0.1对应的二进制是 1  * 1.1001100110011……*2^-4，
符号位是0,
偏移量为：1019，
小数部分：1.1001100110011……，
由于小数部分超过52位，所以需要截断从而会导致精度丢失。
所以，**当 0.1 存下来的时候，就发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。**

### 如何解决？

**方法一：`toFixed(n)`**
我们可以借助方法 `toFixed(n)` 对结果进行舍入。

```js
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30
```

注意：`toFixed` 总是返回一个字符串。我们可以使用一元加号将其强制转换为一个数字：
```js
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // "0.30"
```

**方法二：将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。**

```js
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
```

**方法三：使用 Number.EPSILON。如果两个数的精度损失在允许范围内，则可以认为两个数是相等的。**

`Number.EPSILON` 属性表示 1 与 `Number` 可表示的大于 1 的最小的浮点数之间的差值。

```js
function numbersCloseEnoughToEqual(n1, n2) {
    return Math.abs(n1 - n2) < Number.EPSILON;
}

let a = 0.1 + 0.2;
let b = 0.3;

numbersCloseEnoughToEqual(a, b); // true
numbersCloseEnoughToEqual(0.0000001, 0.0000002); // false
```

### 小练习：

下面代码的打印结果是什么？

```js
console.log(9999999999999999); // 16位
```

由于9999999999999999转化为二进制为100011100001101111001001101111110000001111111111111111，
其格式化为1.00011100001101111001001101111110000001111111111111111*2^53,由于小数部分为53位超过了52位，且第52位不为0，53位为1，所以选择向上舍入，于是输出10000000000000000（17位）

## 谈谈 undefined 和 null ？

面试高频指数：★★★★☆

`undefined `和 `null` 都是基本数据类型。它们的定义是：

* `undefined `意味着变量已经声明了但是没有赋值。
* `null` 是空值，可以作为对象的初始值。

### undefined 不是 undeclared

* `undeclared` 是指变量从未在代码中出现.使用未声明的变量就会报错：`ReferenceError: cat is not defined`。
* `undefined` 则是声明了但是值是 undefined 或者值并不存在。

### 如何获取安全的 undefined 值？

因为` undefined` 是一个**标识符**，所以可以被当作变量来使用和赋值，但是这样会影响 `undefined` 的正常判断。
可以使用` void 0 `获得安全的值。

```js
console.log(void 0); // undefined
```

### `??` 和 `??=`

## 空值合并运算符（`??`）

空值合并运算符（`??`）是一个逻辑运算符，判断左边的值是否是 `null `或 `undefined`。如代码 `a ?? b`，如果` a `是` null `或` undefined`，返回 `b`， 反之，返回 `a`。

> a ?? b 可以理解为: a !== undefined && a !== null ? a : b

我们可以给值为` null `或` undefined` 的变量一个默认值。如下面的代码所示：

```js
let firstName = null, lastName = 'Sun';
let fullName = firstName ?? lastName
console.log(fullName); // Sun
```

## `??` vs `||`

`??` 和 `||` 的相同点：都可以为值为 `null` 或 `undefined` 的变量赋默认值。如下面代码：

```js
let firstName = null, lastName = 'Sun';
let fullName = firstName ?? lastName
console.log(fullName); // Sun

fullName = firstName || lastName;
console.log(fullName); // Sun
```

不同点在于：

* `?? `只判断值 `null `和` undefined`
* `||` 是**任何假值**（`0`， `''`，` NaN`， `null`，` undefined`）都不会被返回。这导致如果你使用 `0`，`'' `或` NaN `作为有效值，就会出现不可预料的后果。

如下面代码，判断值是 `''` 时两者的不同表现：

```js
let firstName = '', lastName = 'Sun';
let fullName = firstName ?? lastName
console.log(fullName); // ''

fullName = firstName || lastName;
console.log(fullName); // Sun
```

### 逻辑空赋值运算符 `??=`

逻辑空赋值运算符（`x ??= y`）仅在 x 是空值（`null` 或 `undefined`）时对其赋值。
`a ??= b `可以理解为:` a ?? (a = b) `。

如下面的代码：

```js
let firstName = null;
firstName ??= 'yangyang'
console.log(firstName); // 'yangyang'
```

## type of null

面试高频指数：★★★★☆

JavaScript 中，`typeof null`是 `object`，这是不对的，因为 `null` 是基本数据类型，不是对象。这是个 bug，但是因为修复这个 bug 会影响现存的代码，所以就一直没改。

这个问题的起源可以追溯到 JavaScript 早期版本的一个设计错误。在 JavaScript 的初始版本中，用于存储值的变量被实现为 32 位的单词，其中的前三位用于存储数据类型信息。当这三位的值为 000 时，表示该变量的数据类型是对象。

而 null 被定义为一个空指针对象，因此它的内部存储表示是全零，即前三位为 000。这就导致了 `typeof null` 返回 `"object"`。

### 小练习

`typeof NaN` 返回什么？

答案：`typeof NaN` 返回 `'number'`。`NaN` 表示不是一个数字，它是 `Number` 的特殊值。

## JS如何做类型转换

面试高频指数：★★★★★

使用` == `会发生隐式类型转换，`=== `会严格判断两者的类型是否相等。我们也可以显式调用类型转换方法去转换类型，如使用` toString() `等。

通常来说，隐式类型转换的难点主要有两点：

* 使用 + 运算符
  * 作为一元运算符，转换成数字
  * 作为二元运算符，将两个操作数转成字符串，再进行拼接
* 对象的隐式转换
  * 任意对象都有 `toString `方法，将返回` [object Object]`
  * 但是数组例外，`toString `方法将返回由逗号分隔的一系列数字组成的字符串

### 小练习

给出下列代码输出结果：

```js
console.log(1 +  "2" + "2"); // 122
console.log(1 +  +"2" + "2"); // 32
console.log(1 +  -"1" + "2"); // 02
console.log(+"1" +  "1" + "2"); // 112
console.log( "A" - "B" + "2"); // NaN2
console.log( "A" - "B" + 2); // NaN
console.log("10,11" == [[[[10]],11]]) // 10,11 == 10,11, 答案: true
console.log("[object Object]" == {name: "test"}) // true

```

## ==、===和Object.is()的区别

面试高频指数：★★★★☆

JavaScript 提供三种不同的值比较操作：

* 严格相等比较，使用 `===`
* 抽象相等比较，使用 `==`
* 以及` Object.is `（ECMAScript 2015/ ES6 新特性）

`==`总结：

1. 如果操作数具有相同的类型，则按如下方式进行比较：
   - 字符串（String）：只有当两个操作数具有相同的字符且顺序相同时才返回 `true`。
   - 数值（Number）：如果两个操作数的值相同，则返回 `true`。`+0` 和 `-0` 被视为相同的值。如果任何一个操作数是 `NaN`，返回 `false`；所以，`NaN` 永远不等于 `NaN`。
   - 布尔值（Boolean）：仅当操作数都为 `true` 或都为 `false` 时返回 `true`。
   - 大整形（BigInt）：仅当两个操作数值相同时返回 `true`。
   - 对象（Object）：仅当两个操作数引用同一个对象时返回 `true`。
   - 符号（Symbol）：仅当两个操作数引用相同的符号时返回 `true`。
2. 如果其中一个操作数为 `null` 或 `undefined`，另一个操作数也必须为 `null` 或 `undefined` 以返回 `true`。否则返回 `false`。
3. 如果其中一个操作数是对象，另一个是基本类型，按此顺序使用对象的 [`@@toPrimitive()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)（以 `"default"` 作为提示），[`valueOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf) 和 [`toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 方法将对象转换为基本类型。（这个基本类型转换与[相加](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Addition)中使用的转换相同。）
4. 在这一步，两个操作数都被转换为基本类型（String、Number、Boolean、Symbol 和 BigInt 中的一个）。其余的转换是逐个进行的。
   - 如果是相同的类型，使用步骤 1 进行比较。
   - 如果其中一个操作数是 Symbol 而另一个不是，返回 `false`。
   - 如果其中一个操作数是布尔型而另一个不是，则将布尔型转换为数字：`true` 转换为 1，`false` 转换为 0。然后再次松散地比较两个操作数。
   - Number to String：使用与 [`Number()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/Number) 构造函数相同的算法将字符串转换为数字。转换失败将导致 `NaN`，这将保证相等是 `false`。
   - Number to BigInt：按数值进行比较。如果数值为 ±∞ 或 `NaN`，返回 `false`。
   - String to BigInt：使用与 [`BigInt()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt) 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 `false`。

简而言之，在比较两件事情时：

* `==` 将执行类型转换

* `===` 将进行相同的比较，不做类型转换

* `Object.is`基本和`===`相同

  区别在于：

  * 他们对待有符号的`0`和`NaN`不同，`===`运算符将`+0`和`-0`视为相等，而将`Number.NaN`与`NaN`视为不等。而`Object.is()`将`+0`和`-0`视为不相等，将`NaN`和`Number.NaN`视为相等

```js
// ===
console.log(0 === -0); // true
console.log(NaN === NaN); // false

// Object.is 
console.log(Object.is(0, -0)); // false
console.log(Object.is(NaN, NaN)); // true
```

## Js判断数据类型的方法

面试高频指数：★★★★☆

有四种方法：

**方法一：`typeof`**

`typeof` 运算符返回一个字符串，表示操作数的类型。下图是使用 `typeof` 判断类型的汇总：

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675251187-xvNewe-image.png)

可以看到，`typeof` 判断类型有两个缺点：

- 对 `null` 值的判断是 `object`，这个是历史遗留问题
- 对 `object` 的判断区分不出具体的对象类型

**方法二： `instanceof`**

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

```js
// 定义构造函数
function C(){}
function D(){}
var o = new C();
o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype
```

**方法三：`Object.prototype.constructor`**

`constructor` 属性返回 `Object` 的构造函数（用于创建实例对象）。

注意：此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。

所有对象（使用` Object.create(null) `创建的对象除外）都将具有` constructor `属性。在没有显式使用构造函数的情况下，创建的对象（例如对象和数组文本）将具有` constructor` 属性，这个属性指向该对象的基本对象构造函数类型。

```js
const o = {}
o.constructor === Object // true

const o = new Object
o.constructor === Object // true
```

**方法四：`Object.prototype.toString`**

`Object.prototype.toString` 方法返回一个表示该对象的字符串。

```js
const toString = Object.prototype.toString;
toString.call(new Date()); // [object Date]
toString.call(new String()); // [object String]
```

### 小练习

如何实现 `instanceof`？

```js
function myInstanceof(son,parent){
   let temp=Object.getPrototypeOf(son);//获得指定对象的原型
   let prototype=parent.prototype;     //获取构造函数的prototype;
   while (true){
       if(!temp) return false
       if(temp===prototype) return true;
       temp=Object.getPrototypeOf(temp)
   }
}
```

#  第三章 操作符

## ||==、&&=、??=是什么？

面试高频指数：★★☆☆☆

x ||= y：如果 x 为假，将 y 赋值给 x。
x &&= y：如果 x 为真，将 y 赋值给 x。
x ??= y：如果 x 为空值（null 或 undefined），将 y 赋值给 x。
例如，逻辑或赋值 ||= 的应用：

```js
const a = { duration: 50, title: '' };

a.duration ||= 10;
console.log(a.duration); // 50

a.title ||= 'title is empty.';
console.log(a.title); // "title is empty"
```

## 可选链?.有什么用？

面试高频指数：★★★☆☆

MDN 上对可选链的定义：

> 可选链运算符（`?.`）允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。

`?.` 运算符的功能类似于 `.` 链式运算符，不同之处在于，在引用为空 (`null` 或者 `undefined`) 的情况下不会引起错误，返回 `undefined`。

可选链可以帮助我们减少判断有效值的代码，特别是深层嵌套对象下访问某个属性，如果属性不存在，不会引起错误。

如果调用对象上不存在的函数，会报错，如下图：

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1676443233-ZyUkWt-image.png)

如果使用 `?.` 判断函数调用，就不会报错，如面代码：

```js
let person = {
  name: "zhangsan",
  details: { age: 20 }
}

console.log(person.getGender?.())
```

空值合并操作符可以在使用可选链时设置一个默认值：
```js
let person = {
  name: "zhangsan",
  details: { age: 20 }
}
let add = person?.city ?? '默认值';
console.log(add) // '默认值'
```

# 第四章 对象

## JavaScript 创建对象有哪些方式？

面试高频指数：★★★★☆

创建对象的方式：

* 三种最基本的方式
  * `Object` 构造函数
  * 对象字面量
  * `Object.create()`
* 类（语法糖）
* 四种运用原型式继承的方式。ES6 开始正式支持类和继承，涵盖了之前规范设计的基于原型的继承模式。
  * 工厂模式
  * 构造函数模式
  * 原型模式
  * 组合模式

**一、`Object` 构造函数**

创建自定义对象可以创建 `Object` 的一个新实例，再添加属性和方法，如下所示：

```js
let obj=new Object();
```

**二、对象字面量**

```js
let obj={
    name:"张三"
}
```

**三、`Object.create()`**

`Object.create()`方法创建一个新的对象，使用现有的对象作为新创建对象的原型。

```js
let person = {
  name: "Lucy",
  sayName() {
    console.log(this.name)
  }
}

let person1 = Object.create(person);
console.log(person1.name); // "Lucy"。
```

**四、类（ES6）**

类用于创建对象的模版，它建立在原型上。类是“特殊的函数”，类语法有两个组成部分：类表达式和类声明。
我们用类声明来创建一个对象：

```js
class Person {
  constructor(name) {
    this.name = name;
  }
	// 定义方法
  sayName() {
    console.log(this.name)
  }
}

const person1 = new Person("Lucy");
person1.sayName(); // "Lucy"
```

注意：函数声明和类声明的一个重要区别是：函数声明会提升，类声明不会。
我们用类表达式来创建一个对象，类表达式可以是命名或不命名的，如下用匿名类创建对象：

```js
let Person = class {
  constructor() {}
}
```

> 类相比原型模式，具备原型模式的优点，代码封装更好。

**五、工厂模式**

工厂模式是一种运用广泛的设计模式，用于抽象创建特定对象的过程。如下所示：

```js
function createPerson(name) {
  let o = new Object();
  o.name = name;
  o.sayName = function() {
    console.log(this.name);
  };
  return o;
}

let person1 = createPerson("Lucy");
let person2 = createPerson("Joe");
```

函数 `createPerson()`接收 1 个参数 `name`， 根据这个参数创建了一个包含` Person `信息的对象，可以用不同的参数多次调用这个函数，每次都会返回包含 1 个属性和 1 个方法的对象。在 `createPerson()` 中可以根据实际需求给 `Person `对象添加更多属性和方法。
它的优缺点如下：

* 优点：可以解决创建多个类似对象的问题
* 缺点：没有解决对象标识问题（即新创建的对象是什么类型，类型如 Array）

**六、构造函数模式**

构造函数是用于创建特定类型对象的。像` Object `和 `Array `这样的原生构造函数，运行时可以直接在执行环境中使用。我们可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。
```js
function Person(name) {
	this.name = name;
    this.sayName = function() {
        console.log(this.name)
    }
}

let person1 = new Person("Lucy");
let person2 = new Person("Joe");

person1.sayName(); // "Lucy"
person2.sayName(); // "Joe"
```

在这个例子中，`Person() `构造函数代替了` createPerson() `工厂函数。实际上，`Person()` 内部的代码和` createPerson() `基本是一样的，只是有如下区别：

* 没有显式地创建对象
* 属性和方法直接赋值给了` this`
* 没有` return`

另外，需要注意函数名 `Person `大写了。按照惯例，**构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。**这是为了区别构造函数和普通函数，毕竟 ECMAScript 的构造函数就是能创建对象的函数。
要创建` Person` 的实例，应使用 `new `操作符，用 `new `操作符调用构造函数会执行如下操作：

1. 在内存中创建一个新对象
2. 这个新对象内部的 `[[Prototype]]` 特性被赋值为构造函数的` prototype` 属性
3. 构造函数内部的 `this` 被赋值为这个新对象（即 `this` 指向新对象）
4. 执行构造函数内部的代码
5. 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象。

那么 `new` 是如何具体实现的呢？我们可以模拟一个 `new` 的实现，由于 `new` 是个关键字，我们把构造函数当作函数的参数传入：

```js
function newOperator(Constructor, ...args) {
  let thisValue = Object.create(Constructor.prototype);  // 对应上文操作步骤： 1、2
  let result = Constructor.apply(thisValue, args); // 对应上文操作步骤： 3、4
  return typeof result === 'object' && result !== null ? restult : thisValue; // 对应上文操作步骤： 5
}

// 测试代码

function Person(name) {
	this.name = name;
    this.sayName = function() {
        console.log(this.name)
    }
}

let person1 = newOperator(Person, "Lucy");
let person2 = newOperator(Person, "Joe");

person1.sayName(); // "Lucy"
person2.sayName(); // "Joe"
```

上文中创建的 `person1` 和 `person2` 都分别保存着 `Person` 的不同实例。这两个对象都有一个 `constructor` 属性指向 `Person`：
```js
console.log(person1.constructor === Person) // true
console.log(person2.constructor === Person) // true
```

`constructor` 是用于标识对象类型的，`instanceOf` 操作符也可以确定对象类型。如下所示：

```js
console.log(person1 instanceof Object);  // true
console.log(person1 instanceof Person);  // true
```

自定义构造函数模式的优缺点如下：

- 优点：可以确保实例被标识为特定类型，相比于工厂函数，这是一个很大的好处。
- 缺点：定义的方法在每个实例上都创建一遍。

这个缺点从上文的例子来看，person1 和 person2 的都有名为 sayName() 的方法，但这两个方法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：

```js
function Person(name) {
  this.name = name;
  this.sayName = new Function("console.log(this.name");
}
```

这样理解这个构造函数可以更清楚知道，每个 Person 实例都会有自己的 Function 实例用于显示 name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function 实例的机制是一样的，因此不同实例上的函数虽然同名却不相等，如下所示：

```js
console.log(person1.sayName === person2.sayName); // false
```

因为都是做一样的事，所以没必要定义两个不同的 `Function` 实例。况且，`this` 对象可以把函数与对象的绑定推迟到运行时。
要解决这个问题，我们可以把函数定义转移到构造函数外部：

```js
function Person(name){
    this.name = name;
    this.sayName = sayName;
}
function sayName() {
      console.log(this.name);
}

let person1 = new Person("Lucy");
let person2 = new Person("Joe");

person1.sayName();  // "Lucy"
person2.sayName();  // "Joe"
```

`sayName() `被定义到了函数的外部，构造函数内部，`sayName` 属性指向的是全局 `sayName() `函数，所以 `person1` 和` person2 `共享了定义在全局作用域上的` sayName` 函数。
虽然这样解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，代码也不能很好地聚集在一起。这个新问题可以通过原型模式解决。
**七、原型模式**

每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。

```js
function Person() {};

// 将属性和方法添加到 prototype 属性上
Person.prototype.name = "Lucy";
Person.prototype.sayName = function() {
  console.log(this.name)
}

let person1 = new Person();
person1.sayName(); // "Lucy"

let person2 = new Person();
person2.sayName(); // "Lucy"
```

**八、组合模式**

组合模式是原型模式和构造函数模式的结合。

```js
function Person(name) {
  this.name = name;
}

Person.prototype = {
  constructor: Person,
  sayName: function() {
    console.log(this.name)
  }
};

let person1 = new Person("Lucy");
let person2 = new Person("Joe");

person1.sayName(); //"Lucy"
person1.constructor === Person; // true

person2.sayName(); //"Joe"
person2.constructor === Person; // true
```

我们重写 `prototype` 对象时，最好保证 `constructor` 属性的正确性。
组合模式的优点是该共享的共享了，缺点是封装性不够好。

## 如何理解继承和原型链？

面试高频指数：★★★★☆

JavaScript 中对象可以通过原型继承其他对象的特征。每个对象都有自己的 prototype 属性，叫做原型 。原型和原型链的出现给代码复用提供了解决方案。MDN 的定义如下：

>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（`object`）都有一个私有属性（称之为 `__proto__`）指向它的构造函数的原型对象（`prototype`）。该原型对象也有一个自己的原型对象（`__proto__`），层层向上直到一个对象的原型对象为` null`。根据定义，`null `没有原型，并作为这个原型链中的最后一个环节。

**`prototype` 对象**

几乎所有 JavaScript 中的对象都是位于原型链顶端的` Object` 的实例。`Object()` 是 JavaScript 内置的函数。注意` Object() `是函数，不是对象 `object`，调用` Object() `后返回一个新的对象。

```js
typeof(Object) // "function"
```

`Object()`函数有一个匿名的对象，可以通过 `prototype` 属性访问：

* `Object.prototype `对象上有很多有用的属性和方法，如` toString()`
* `Object.prototype `有个重要的属性` constructor`，它指向` Object()` 函数，`Object.prototype.constructor === Object`。

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675850248-VbmLtb-image.png)

我们定义一个构造函数：

```js
function Person(name){
	this.name = name;
}
```

JavaScript 创建了一个新的函数 `Person()` 并且有匿名的对象 `prototype`：

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675850423-fNUScP-image.png)

和 `Object() `函数一样，`Person() `函数也有自己的 `prototype `指向一个匿名的对象，这个对象也有` constructor` 属性指向` Person()` 函数。

```js
function Person(name){
	this.name = name;
}

console.log(Person);
console.log(Person.prototype);
```

运行后可发现：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode01.png)

**此外，JavaScript 将 `Person.prototype` 对象和 `Object.prototype` 对象通过 `[[Prototype]]` 连接。**

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode02.png)

### 原型链

**获取原型链**

`__proto__`是 `Object.prototype `对象的可访问属性，它是内部原型链`[[prototype]]`对象对外暴露的可访问属性。
`__proto__`

**在 ES6 中为了确保浏览器的兼容性，建议使用 `Object.getPrototypeOf()`替代。**

```js
console.log(p1.__proto__ === Person.prototype); // true
console.log(p1.__proto__ === Object.getPrototypeOf(p1)); // true
```

注意 `[[Prototype]] `、`__proto__` 和 `prototype` 的关系：

> 遵循 ECMAScript 标准，`someObject.[[Prototype]]` 符号是用于指向 `someObject` 的原型。从 ECMAScript 6 开始，`[[Prototype]] `可以通过 `Object.getPrototypeOf() `和 `Object.setPrototypeOf() `访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 `__proto__`。但它不应该与构造函数` func `的 `prototype` 属性相混淆。被构造函数创建的实例对象的` [[Prototype]]` 指向` func` 的 `prototype` 属性。`Object.prototype` 属性表示` Object `的原型对象。
>

**原型链**

我们可以通过 `prototype` 对象添加属性和方法：

```js
Person.prototype.greet = function() {
  return "Hi, I'm" + this.name + "!";
}
```

创建一个新的 `Person` 实例：

```js
let p1 = new Person("John");
```

JavaScript 创建了一个新的对象` p1 `并将` p1 `对象和 `Person.prototype` 对象通过原型连接起来。
原型链，就是下图中黄字部分的链状结构。
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode03.png)

我们可以用下面的代码验证：

```js
function Person(name) {
    this.name = name;
}

let p1 = new Person("John");

p1.__proto__ === Person.prototype; // true (1)
Person.__proto__ === Function.prototype; // true (2)
Function.__proto__ === Function.prototype; // true (3)
Function.prototype.__proto__ === Object.prototype; // true (4)
Object.prototype.__proto__ === null; // true (5)
```

从上可知：

* p1 是构造函数 Person 创建的实例，它的内部原型链 [[Prototype]] 对象指向构造函数 Person 的原型对象 prototype。（代码 1 处）
* 构造函数 Person 的内部原型链 [[Prototype]] 对象指向构造函数 Function 的原型对象 prototype。（代码 2 处）
* 函数和对象也会一直向上查找，直到 null 为止。（代码 3、 4、 5处）

**性能**
在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。
遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从` Object.prototype` 继承的 `hasOwnProperty `方法。

```js
function Person(name) {
    this.name = name;
}

let p1 = new Person("John");

console.log(p1.hasOwnProperty("name")); // true
console.log(p1.hasOwnProperty("toString")); // false
```

**总结**

* `Object()` 函数有一个 `prototype `属性，指向` Object.prototype` 对象
* `Object.prototype` 对象有对象所有的的属性和方法，比如` toString()`、`valueOf()`。
* `Object.prototype` 对象有` constructor` 属性，指向` Object` 函数。
* 每个函数都有一个` prototype `对象，这个原型对象的 `__proto__ `指向 `Object.prototype`， 通过 `[[prototype]] `或者` __proto__` 属性查找属性和方法。
* `Object.getPrototype() `方法返回给定对象的原型对象，建议使用 `Object.getPrototypeOf() `替代 `__proto__`。
* 通过` hasOwnProperty` 检查对象是否具有自己定义的属性。

**小练习**

下面代码的输出结果是什么？
```js
Function.__proto__ === Object.prototype; // false
Object instanceof Function; // true
Function instanceof Object; // true
```

## 继承有哪几种方式？

面试高频指数：★★★☆☆

JavaScript 继承方式有以下五种：

- 原型继承
- 借用构造函数继承
- 组合继承
- 寄生式继承
- 寄生组合式继承

### 原型链

构造函数、原型和实例的关系是：每个构造函数都有一个原型对象 protptype，原型有一个属性 constructor 指向构造函数，而实例有一个内部指针 __proto__ 指向原型。如果原型是另一个类型的实例呢？原型链就是基于此构想。
```js
function Parent () {
    this.name = "kevin";
}

Parent.prototype.getName = function () {
    console.log(this.name);
    return this.name
}

function Child () {

}

Child.prototype = new Parent();

let child1 = new Child();

console.log(child1.getName()) // kevin
```

缺点：

- 引用类型的属性被所有实例共享
- 不能向 `Parent` 传参

### 借用构造函数继承

```js
function Parent () {
    this.names = ["kevin", "daisy"];
}

function Child () {
    Parent.call(this);
}

let child1 = new Child();
child1.names.push("Lucy");
console.log(child1.names); // ["kevin", "daisy", "Lucy"]

let child2 = new Child();
console.log(child2.names); // ["kevin", "daisy"]
```

优点：
解决了原型链继承存在的两个缺点。

* 避免了引用类型的属性被所有实例共享
* 能向 Parent 传参

缺点：

* 方法都在构造函数中定义，每次创建实例都会创建一遍方法。

### 组合继承

```js
function Parent (name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

let child1 = new Child("kevin", "18");
child1.colors.push("black");
console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

let child2 = new Child("daisy", "20");
console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

### 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

```js
function createObj (o) {
    let clone = Object.create(o);
    clone.sayName = function () {
        console.log("hi");
    }
    return clone;
}
```

缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

### 寄生组合式继承

```js
function Parent (name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

// 封装创建新的对象的方法，以传入的原型作为新对象的原型
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}

function prototype(child, parent) {
    var prototype = object(parent.prototype);
    prototype.constructor = child;
    child.prototype = prototype;
}

prototype(Child, Parent);

let child1 = new Child("kevin", "18");

child1.colors.push("black");

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

let child2 = new Child("daisy", "20");

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

这种方式的高效率体现它只调用了一次 `Parent `构造函数，并且因此避免了在 `Parent.prototype` 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用` instanceof `和 `isPrototypeOf`。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。

## Map 和 WeakMap 有什么区别？

面试高频指数：★★★☆☆

`WeakMap` 提供的接口与 `Map` 相同，但是它们有以下的区别：

|             | `Map`                                                        | `WeakMap`                                                    |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义        | `Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。 | `WeakMap` 对象是一组键/值对的集合，其中的**键是弱引用**的。其键必须是对象，而值可以是任意的 |
| 键值（key） | 1. key 可以是任何值（对象或者基本类型）<br />2. key 是唯一的<br />3. key 可枚举，如使用 `for...of` | 1. key 必须是对象，原始数据类型不可作为 key<br />2. key 不可枚举 |
| 垃圾回收    | 不使用                                                       | `WeakMap` 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。 |
| 有无size    | 有                                                           | 无                                                           |

### `Map`

> `Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。

**创建和设置对象属性**

下面展示创建 `Map` 和它的方法的使用：

```js
// 创建
const users = new Map();

// String 作为 key
users.set("John", { address: "John's Address" });

// Object 作为 key
const obj = { name: "Michael" };
users.set(obj, { address: "Michael's Address"});

// Function 作为 key
const func = () => "Andrew";
users.set(func, { address: "Andrew's Address"});

// NaN 作为 key
users.set(NaN, { address: "NaN's Address"});
```

一些方法的使用如下：
```js
const contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.delete("Raymond"); // false
console.log(contacts.size); // 1
```

**Map vs Object**

`Object` 和` Map `类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Map 使用。
不过` Map `和 `Object `有一些重要的区别，在下列情况中使用 Map 会是更好的选择：

|              | `Map`                                                | `Object`                                                     |
| ------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| 意外的键     | 包含显示插入的键                                     | `Object` 有原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。 |
| 键的类型     | 键可以是**任意值**，包括函数、对象或任意基本类型。   | `Object` 的键必须是一个 `String` 或是 `Symbol`。             |
| 键的顺序     | 有序。                                               | 虽然 `Object` 的键目前是有序的，顺序是复杂的。因此，最好不要依赖属性的顺序 |
| Size         | 可通过 `size` 属性获取。                             | 键值对个数只能手动计算。                                     |
| 迭代         | 可迭代                                               | `Object` 没有实现迭代协议，所以使用 `for...of` 表达式并不能直接迭代对象。`for...in` 表达式允许你迭代一个对象的可枚举属性。 |
| 性能         | 在频繁增删键值对的场景下表现更好。                   | 在频繁添加和删除键值对的场景下未作出优化。                   |
| 序列化和解析 | 没有元素的序列化和解析的支持。可以自己实现这个需求。 | 可以使用 `JSON.stringify()`、`JSON.parse()`互相转换。        |

### `WeapMap`

> **`WeakMap`** 对象是一组键/值对的集合，其中的键是弱引用的。**其键必须是对象**，而值可以是任意的。

**创建和设置对象属性**

**设置对象**

```js
const test = new WeakMap()
const o1 = {};
test.set(o1, {name: 'test'});
```

**获取对象**

```js
const test = new WeakMap();
const o1 = function () {};
test.set(o1, { name: "test" });
test.get(o1);
```

**删除和查询对象**

```js
const test = new WeakMap();
const o1 = function () {};
test.set(o1, { name: "test" });
test.has(o1); // true
test.delete(o1);
test.has(o1); // false
```

**应用**
`WeakMap`对象的一个用例是存储一个对象的私有数据或隐藏实施细节。

```js
const privates = new WeakMap();

function Public() {
  const me = {
    // 私有数据
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(
  );
  // ...
};

module.exports = Public;

```

**总结**
`Map` 和` WeakMap` 的功能以及方法（都有 `get()`、 `set()`、`has()`、`delete()`）是一样的，它们区别有以下四个方面：

* 定义
* 键值（key）
* 垃圾回收
* 有无 size 属性

## 如何实现深拷贝和浅拷贝？

面试高频指数：★★★★★

深拷贝和浅拷贝都是针对数据类型是 `Object` 而言，因为对象是引用类型，如果要拷贝一个副本，副本中的对象更改后，不影响到原对象（或修改原对象不影响副本），即为深拷贝，否则，为浅拷贝。

这是因为，计算机存储数据有两种内存：`stack` 和 `heap`：

* `stack` 是一个临时存储空间，存放的是原始值变量和对象的引用。
* `heap` 存储全局变量，对象的值都是存在 `heap` 中，`stack` 中保存的是对象的引用。

下图可以帮助更好理解：

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/1675246788-HjXqny-image.png)

这里将介绍 4 种浅拷贝的方法和 4 种深拷贝的方法。


### 浅拷贝（shallow copy）

浅拷贝对原对象或副本的更改可能也会导致其他对象的更改。它实际上只拷贝了一层，并且只当数组和对象包的值是原始值时才进行拷贝。

**赋值运算符 `=`**

如果将一个对象赋值给另一个对象，也是浅拷贝.
```js
const array = [1, 2, 3];

const copyWithEquals = array;
console.log(copyWithEquals === array); // true 
```

**扩展运算符 `...`**

扩展运算符 `...` 可以很方便地浅拷贝对象和数组：

```js
const array = [1, 2, 3];

const copyWithSpread = [...array];
console.log(copyWithSpread === array); // false
array[0][0]=0;
console.log(array)          //=>[ [ 0 ], 2, 3 ]
console.log(copyWithSpread)  //=>[ [ 0 ], 2, 3 ]
```

`.slice()`

数组可以使用内置的方法` .slice()`，它的作用和扩展运算符一样，都可以实现浅拷贝：

```js
const array = [[1], 2, 3];

const copyWithSlice = array.slice();
console.log(copyWithSlice === array); // false
array[0][0]=0;
console.log(array)          //=>[ [ 0 ], 2, 3 ]
console.log(copyWithSlice)  //=>[ [ 0 ], 2, 3 ]
```

`.assign()`

使用 `Object.assign()` 也可以实现对象和数组的浅拷贝：

```
const array = [[1], 2, 3];

const copyWithAssign = Object.assign([], array); 

console.log(copyWithAssign === array); // false
array[0][0]=0;
console.log(array)          //=>[ [ 0 ], 2, 3 ]
console.log(copyWithAssign)  //=>[ [ 0 ], 2, 3 ]
```

`Array.from()`

**Array.from()** 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

```js
const array = [[1], 2, 3];

const copyWithArrayFrom = Array.from(array);

console.log(copyWithArrayFrom===array) //=>false
array[0][0]=0;
console.log(array)          //=>[ [ 0 ], 2, 3 ]
console.log(copyWithArrayFrom)  //=>[ [ 0 ], 2, 3 ]
```

### 深拷贝（deep copy）

JavaScript 对象和数组如果深度嵌套，浅拷贝只能实现第一层的拷贝，但是深度的值依然和原对象共享引用。

```js
const nestedArray = [[1], [2], [3]];
const nestedCopyWithSpread = [...nestedArray];

nestedArray[0][0] = '4'; // 注意这里

console.log(nestedArray); // [[4], [2], [3]] 原数组被修改了
console.log(nestedCopyWithSpread); // [[4], [2], [3]] 拷贝的数组值也被修改了
```

我们希望的深拷贝是无论是嵌套多少层数组和对象，拷贝的数组、对象和原来的数组、对象互不受影响。
如果数组和对象中还包含其他数组和对象，拷贝这些对象、数组就需要使用深拷贝，否则，改变嵌套的引用将会影响到嵌套的原数组和对象。
深拷贝和浅拷贝的区别在于，浅拷贝对于数组和对象仅仅包含原始值时表现良好，但是数组和对象中嵌套其他数组和对象便不能正确拷贝。

`===` 可以帮助我们理解深浅拷贝：

```js
const nestedArray = [[1], [2], [3]];
const nestedCopyWithSpread = [...nestedArray];

console.log(nestedArray[0] === nestedCopyWithSpread[0]); // true

const nestedCopyWithHack = JSON.parse(JSON.stringify(nestedArray)); // 使用 JSON.stringify() 进行深拷贝
console.log(nestedArray[0] === nestedCopyWithHack[0]); // false 深拷贝之后两个对象用 === 比较不相等
```

**第三方库：`lodash`、`rfdc`**

深拷贝可以使用` lodash `库，使用方法如下：

```js
import _ from "lodash"

const nestedArray = [[1], [2], [3]];
const shallowCopyWithLodashClone = _.clone(nestedArray); 
const deepCopyWithLodashClone = _.cloneDeep(nestedArray);
```

`rfdc` 库也可以实现深拷贝，它的优点是速度快：

```js

const clone = require('rfdc')() // 
clone({a: 37, b: {c: 3700}}) // {a: 37, b: {c: 3700}}
```

`JSON.parse/stringify`

`JSON.parse(JSON.stringify(object))` 也可以实现深拷贝，但是不同类型的值表现各有区别。因此，不建议使用。

```js
// 仅仅下面的数据类型支持使用 JSON.parse()、JSON.stringify()
const sampleObject = {
  string: 'string',
  number: 123,
  boolean: false,
  null: null,
  notANumber: NaN, // NaN 会被忽略
  date: new Date('1999-12-31T23:59:59'),  // Date 将被转成字符串
  undefined: undefined,  // Undefined 会被忽略
  infinity: Infinity,  // Infinity 会被忽略
  regExp: /.*/, // RegExp 会被忽略
}

console.log(sampleObject) 
// Object { string: "string", number: 123, boolean: false, null: null, notANumber: NaN, date: Date Fri Dec 31 1999 23:59:59 GMT-0500 (Eastern Standard Time), undefined: undefined, infinity: Infinity, regExp: /.*/ }
console.log(typeof sampleObject.date) // object

const faultyClone = JSON.parse(JSON.stringify(sampleObject))

console.log(faultyClone) // Object { string: "string", number: 123, boolean: false, null: null, notANumber: null, date: "2000-01-01T04:59:59.000Z", infinity: null, regExp: {} }

console.log(typeof faultyClone.date) // string
```

`structuredClone`

MDN 定义如下：

> 全局的 **structuredClone()** 方法使用结构化克隆算法将给定的值进行深拷贝

`structuredClone` 将返回一个原对象的深拷贝，它的语法如下：

```js
structuredClone(value, options)
```

- `value` 为需要进行深拷贝的对象
- `options` 可选

```js
const nestedArray = [[1], [2], [3]];

const nestedCopyWithStructuredClone = structuredClone(nestedArray); // 深拷贝

console.log(nestedArray === nestedCopyWithStructuredClone); // false

nestedArray[0][0] = 4;
console.log(nestedArray); // [[4], [2], [3]] 修改了原对象
console.log(nestedCopyWithStructuredClone); // [[1], [2], [3]] 复制对象不受影响
```

注意：`structuredClone() `是 ECMAScript 的一部分，虽然被大部分浏览器支持，但是还有部分浏览器不可用（在 360 浏览器中报 `undefined`）。

**自定义函数实现深拷贝**

```js
const deepCopyFunction = (inObject) => {
	let outObject, value, key;

	if (typeof inObject !== "object" || inObject === null) {
		return inObject; // 如果 inObject 不是对象则返回 inObject
	}

	// 创建一个数组或者对象去保存值
	outObject = Array.isArray(inObject) ? [] : {};

	for (key in inObject) {
		value = inObject[key];

		// 递归复制嵌套的对象和数组的值
		outObject[key] = deepCopyFunction(value);
	}

	return outObject;
};

// 测试：
const nestedArray = [[1], [2], [3]];

const nestedCopyWithStructuredClone = deepCopyFunction(nestedArray); // 深拷贝

console.log(nestedArray === nestedCopyWithStructuredClone); // false

nestedArray[0][0] = 4;
console.log(nestedArray); // [[4], [2], [3]] 修改了原对象
console.log(nestedCopyWithStructuredClone); // [[1], [2], [3]] 复制对象不受影响
```

注意：我们需要判断单独判断 null 的类型，因为 typeof null 的结果是 "object"。
模拟实现深拷贝的关键就是使用递归，判断嵌套的值是否还是对象或数组，如果是对象或数组，则继续递归，直到值是原始值为止。

# 第五章 函数

## 什么是闭包

面试高频指数：★★★★★

MDN 定义如下：

>  闭包（closure）是一个函数以及其捆绑的周边环境状态的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。
>  是指在函数内部创建并返回的函数，它可以访问到其外部函数的变量、参数和作用域

### 闭包的特性

如下面的例子：

```js
function person() {
	var name = "John";
	function showName() {
		console.log(name); // 'John'
	}
	return showName;
}
const getPerson = person();
getPerson();
```

`showName()` 函数中并没有定义 name 变量，但是却可以访问到外部函数中 name 变量的值，这就是利用了闭包的特性，即嵌套函数可访问声明于它们外部作用域的变量。

### 词法作用域

词法作用域是**静态作用域**，通俗讲就是它可以访问到变量的范围。

```js
var name = 'John';

function greeting() { 
    let message = 'Hi';
    console.log(message + ' '+ name);
}
```

在上面的例子中：

* 变量` name` 是个全局变量，它可以在任意地方访问到，包括函数 greeting();
* 变量 `message` 是个局部变量，只能在函数 greeting() 中访问到;

### 闭包在循环中

下面这段代码很常见：
```js
for (var index = 1; index <= 3; index++) {
    setTimeout(function () {
        console.log('after ' + index + ' second(s):' + index);
    }, index * 1000);
}
```

这里输出如下：
```js
// after 4 second(s):4
// after 4 second(s):4
// after 4 second(s):4
```

这是因为，var 定义的变量是个全局变量，当 setTimeout 调用时，全局变量index 的值被修改为 4，所以每次打印中获取到的 index 值是 4。
针对上面的问题，可以使用闭包和立即执行函数（IIFE）搭配解决。

### 闭包

```js
for (var index = 1; index <= 3; index++) {
    (function (index) {
        setTimeout(function () {
            console.log('after ' + index + ' second(s):' + index);
        }, index * 1000);
    })(index);
}

// 输出
// after 1 second(s):1
// after 2 second(s):2
// after 3 second(s):3
```

上面我们在 setTimeout 函数外使用了立即执行函数，立即执行函数 index 是局部变量，与全局变量 index 处于不同的作用域，此时 setTimeout 函数中能拿到立即执行函数中的 index 变量的值，因此能够得到正确的输出结果。

### 闭包的应用

* **缓存变量的值**

  闭包和函数内传入的值有关联。下面的代码中` createInc `函数调用后，返回一个箭头函数，箭头函数中的` index` 和` startValue` 是外部变量，箭头函数内可以拿到两个变量的值，并且可以对变量的值进行修改。
  我们可以使用闭包的特性缓存变量的值：

  ```js
  function createInc(startValue) {  
      let index = -1;  
      return (step) => {    
          startValue += step;    
          index++;    
          return [index, startValue];  
       };
  }
  const inc = createInc(5);
  console.log(inc(2)); // [0, 7]
  console.log(inc(2)); // [1, 9]
  console.log(inc(2)); // [2, 11]
  ```

* **用闭包模拟私有方法**

  我们可以使用闭包来模拟私有方法。私有方法可以限制对代码的访问，而且可以用于管理全局变量命名，避免扰乱公共代码。

  ```js
  let Counter = (function() {
    let privateCounter = 0;
    function changeBy(val) {
      privateCounter += val;
    }
    return {
      increment: function() {
        changeBy(1);
      },
      decrement: function() {
        changeBy(-1);
      },
      value: function() {
        return privateCounter;
      }
    }
  })();
  
  console.log(Counter.value()); // 0
  Counter.increment();
  Counter.increment();
  console.log(Counter.value()); // 2
  Counter.decrement();
  console.log(Counter.value()); // 1
  ```

  观察上面代码，`Counter `函数立即调用之后，返回一个对象，其中包含三个函数：` increment`、`decrement`、`value`，它们都能访问 `Counter` 函数内部的私有项：`privateCounter` 的变量和名为 `changeBy` 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。


## this的指向有哪些

面试高频指数：★★★★★

函数的调用方式决定了 `this` 的值（运行时绑定）。`this` 不能在执行期间被赋值，并且在每次函数被调用时` this `的值也可能会不同。
this 的指向有以下七种：

### 全局上下文

`this` 指向全局对象

```js
console.log(this === window); // true

a = 37;
console.log(window.a); // 37
```

### 函数上下文

`this` 指向取决于函数被调用的方式：

* 作为对象的方法调用，this 指向该对象
* 作为普通函数调用
  * 非严格模式下，指向全局对象，浏览器中就是 window
  * 严格模式下，为 undefined
* call、apply、bind 调用，this 指向绑定的对象
* 作为构造函数调用，如使用 new，this 指向新的对象

```js
function f1(){
  return this;
}
//在浏览器中：this 指向全局对象 window
f1() === window;  

//在 Node 中：this 指向 global
f1() === global;

// 严格模式下：this 指向 undefined
function f2(){
  "use strict"; 
  return this;
}

f2() === undefined; // true

// call 方法：this 指向传入的指定对象 o
function add(c, d) {
  return this.a + this.b + c + d;
}
var o = {a: 1, b: 3};
add.call(o, 5, 7); // 16
```

### 类上下文

`this` 指向类。在类的构造函数中，`this` 是一个常规对象。类中所有非静态的方法都会被添加到 `this` 的原型中：

```js
class Car {
  constructor() {
      // 使用 bind() 方法改变 this 指向
    this.sayBye = this.sayBye.bind(this);
  }
  sayHi() {
    console.log(`Hello from ${this.name}`);
  }
  sayBye() {
    console.log(`Bye from ${this.name}`);
  }
  get name() {
    return 'Ferrari';
  }
}

class Bird {
  get name() {
    return 'Tweety';
  }
}

const car = new Car();
const bird = new Bird();

// this 指向调用者
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// bind() 方法改变了 this 指向，this 指向类 Car
bird.sayBye = car.sayBye;
bird.sayBye();  // Bye from Ferrari
```

### 箭头函数

`this`与封闭词法环境的 `this` 保持一致。在全局代码中，它将被设置为全局对象。

```js
var window = this;
var foo = (() => this);
console.log(foo() === window); // true
```

### 原型链中的 `this`

如果该方法存在于一个对象的原型链上，那么 `this` 指向的是调用这个方法的对象。

```js
var o = {
  f: function() {
    return this.a + this.b;
  }
};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
```

### 作为一个 DOM 事件处理函数

当函数被用作事件处理函数时，它的 `this` 指向触发事件的元素。

```js
function bluify(e) {
    console.log(this === e.currentTarget); // true
    this.style.backgroundColor = 'blue'
}

// 获取 id 为 test 的 button
let testBtn = document.getElementsById('test');

// 将 bluify 作为元素的点击监听函数，当元素被点击时，就会变成蓝色
testBtn.addEventListener('click', bluify, false);
```

### getter 与 setter 中的 this

用作 `getter` 或 `setter` 的函数都会把 `this` 绑定到设置或获取属性的对象。

```js
var o = {
  a: 1,
  b: 2,
  get sum() {
    return (this.a + this.b);
  }
};

console.log(o.sum); // 输出 3
```

### 小练习

给出下面代码的输出结果：

```js
var length = 10;
function fn() {
  return this.length + 1;
}
var obj = {
  length: 5,
  test1: function() {
    return fn();
  }
};
obj.test2 = fn;

console.log(obj.test1.call()); // (1)
console.log(obj.test1()); // (2)
console.log(obj.test2.call()); // (3)
console.log(obj.test2()); // (4)
```

答案：输出如下：

* 1 处为：11， this 指向 window， 因为 call 方法没有执行具体要绑定的对象。
* 2 处为：11，this 指向 window，返回的 fn 函数的 this 指向 window
* 3 处为：11，原因同 1 处
* 4 处为： 6，this 指向 obj，此处函数作为对象 obj 的方法调用

## 类数组的转化方式有哪些？

面试高频指数：★★★★★

**类数组不是数组，是对象。**

例如` document.getElementsByTagName() `返回的 `NodeList` 或` arguments `等 JavaScript 对象，有与数组相似的行为，但它们并不共享数组的所有方法。`arguments` 对象提供了 `length` 属性，但没有实现如` forEach() `等数组方法。不能直接在类数组对象上调用数组方法。

在函数中，`arguments `对象代表函数实参。`arguments` 对象是一个类数组对象，类数组不是数组，因此它不是 Array 类型的实例，它是 Object 类型的实例。

```js
function add (one, two) {
    console.log(arguments);
    console.log(Array.isArray(arguments));
    console.log(Object.prototype.toString.call(arguments));
}
add(1, 2); 
```

### `arguments` 特点

`arguments` 既然是类数组对象，它有两个特点：

* 可以通过 [] 获取参数， 如` arguments[0]`
* 可以使用` length` 属性获取实参的个数。如 `arguments.length`

```js
function add() {
    let sum = 0;
    for (let i = 0; i < arguments.length; i++) {
        sum += arguments[i];
    }
    return sum;
}

console.log(add(1, 2)); // 3
```

### 类数组转成数组

我们可以使用三种方式将类数组转成数组:

* 扩展运算符
* `Array.from()`
* `slice()`，使用以下两种方式都可以：
  * `Array.prototype.slice.call(arguments)`
  * `[].slice.call(arguments);`

```js
// 扩展运算符
function checkArgs() {
	return [...arguments];
};

let result = checkArgs(1, 2);
console.log(result); // [1, 2]

// Array.from()
function checkArgs() {
	return Array.from(arguments);
};

let result1 = checkArgs(1, 2);
console.log(result1); // [1, 2]

// slice()
function checkArgs() {
	return Array.prototype.slice.call(arguments);
};

let result2 = checkArgs(1, 2);
console.log(result2); // [1, 2]
```

## 如何模拟实现函数方法：call()、apply()、bind()？

面试高频指数：★★★★★

`call()`、`apply()`、`bind()` 三个方法都可以根据指定的 `this` 值调用。

### `call()`

MDN 上 `call()` 的定义：

> **call()** 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。

```js
let foo = {
  value: 1
};

function bar() {
  console.log(this.value); // 1
}

bar.call(foo); 
```

由上面代码可知：

- `call` 改变了 `this` 的指向，指向了 `foo`
- `bar` 函数执行了

因此，我们只要按照下面的步骤来实现 `call()` 即可：

1. 改造 `foo` 对象，给它添加 `bar` 方法
2. 执行 `bar` 方法
3. 复原 `foo` 对象，把添加的 `bar` 方法删掉

下面是对应的代码实现：

```js
Function.prototype.myCall = function (thisArg, ...args) {
    // 判断参数指定的 this 的类型
    // call() 函数在 thisArg 参数为 undefined 或者为 null 时，会将 thisArg 自动指向全局对象
    if (thisArg === undefined || thisArg === null) {
        thisArg = typeof window === 'undefined' ? global : window;
    }
    thisArg = Object(thisArg);
    // 为了避免覆盖 thisArg 上面同名的方法/属性，我们借用 Symbol 生成对应属性名
    const key = Symbol('fn');

    // 改造对象，添加方法
    thisArg[key] = this;

    // 执行方法
    const result = thisArg[key](...args);

    // 复原对象，删除方法
    delete thisArg[key];

    return result;
}
```

### `apply()`

该方法的语法和作用与 call() 方法类似，只有一个区别，就是 call() 方法接收的是一个**参数列表**，而 apply() 方法接受的是**一个包含多个参数的数组**。
apply() 的模拟实现：

```js
Function.prototype.myApply = function (thisArg, args) {
  if (thisArg === null || thisArg === undefined) {
    thisArg = typeof window === undefined ? global : window
  }
  thisArg = Object(thisArg)
  const key = Symbol('fn')
  thisArg[key] = this              //此处this指向被调用的方法
  const result = args ? thisArg[key](...args) : thisArg[key]()
  delete thisArg[key]
  return result
}
```

### `bind()`

MDN 对 `bind()` 的定义：

> bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
>

`bind()` 和 `call()` 的区别有两点：

- 它返回的是一个新的函数
- 如果使用 `new` 运算符调用，则忽略传入的 `this` 值

模拟实现如下：

```js
Function.prototype.myBind = function (context) {
  // 保存 this 指向
  const self = this;
  // 获取参数
  const args = Array.prototype.slice.call(arguments, 1);
  
  // 构造原型链
  const F = function () {};
  F.prototype = this.prototype;

  // 创建新的函数
  const bound = function () {
    // 获取其余参数
    const innerArgs = Array.prototype.slice.call(arguments);
    // 将两次获取的参数拼接起来
    const finnalArgs = args.concat(innerArgs);
    // 判断是否是作为构造函数调用
    return self.apply(this instanceof F ? this : context, finnalArgs);
  };

  bound.prototype = new F();
  return bound;
};
```

## 立即调用函数表达式（IIFE）有什么特点？

面试高频指数：★★★☆☆

**IIFE**（立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。

```js
(function () {
    // statements
})();
```

主要包含两部分：

* 包围在圆括号运算符 () 中的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 的变量，而且又不会污染全局作用域。
* 再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。
  特点

### 特点

1. 当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。

```js
(function () {
	var test = "Barry";
})();
// 无法从外部访问变量 test
console.log(test); // 抛出错误："Uncaught ReferenceError: test is not defined"
```

2. 将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。

```js
var result = (function () {
	var name = "Barry";
	return name;
})();
// IIFE 执行后返回的结果：
result; // "Barry"
```

### 运用：模块化封装

模块化封装可以有效组织代码，并且减少了全局变量的污染。

```js
let counter = (function () {
	let i = 0;
	return {
		get: function () {
			return i;
		},
		set: function (val) {
			i = val;
		},
		increment: function () {
			return ++i;
		}
	};
})();

counter.get(); // 0
counter.set(3);
counter.increment(); // 4
counter.increment(); // 5

conuter.i; // undefined (`i`不是返回对象的属性)
i; // ReferenceError: i 未定义，它是立即调用函数表达式的私有变量
```

## 箭头函数有什么特点？

面试高频指数：★★★★☆

箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 this，arguments，super 或 new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。

```js
// 当只有一个参数时，圆括号是可选的：
(singleParam) => { statements }
singleParam => { statements }

// 没有参数的函数应该写成一对圆括号。
() => { statements }
```

**引入箭头函数有两个方面的作用：更简短的函数并且不绑定 `this`。**

### 特点

* 没有单独的 `this`
* **箭头函数不会创建自己的 `this`，它只会从自己的作用域链的上一层继承 `this`。**

```js
function Person() {
	this.age = 0;

	setInterval(() => {
		// this 正确地指向 p 实例
		console.log(this === p) // true
		this.age++; 
	}, 1000);
}

var p = new Person();
```

### 与严格模式的关系

鉴于 `this` 是词法层面上的，严格模式中与 `this` 相关的规则都将被忽略。

```js
var f = () => { 'use strict'; return this; };
f() === window; // 或者 global
```

### 通过 `call` 、`apply` 或 `bind` 调用

由于箭头函数没有自己的 `this`，通过这些方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。
```js
let adder = {
	base: 1,
	add: function (a) {
		console.log(this === adder); // true
		let f = (v) => v + this.base;
		return f(a);
	},
	addThruCall: function (a) {
		let f = (v) => v + this.base;
		let b = {
			base: 2
		};
		// call() 方法重新执行 this 为 b 对象
		return f.call(b, a);
	}
};

console.log(adder.add(0)); // 输出 1
console.log(adder.addThruCall(1)); // 输出 2
```

### 使用箭头函数作为方法

箭头函数中没有定义 `this` 绑定。

```js
"use strict";
var obj = {
	i: 10,
	b: () => console.log(this.i, this), // undefined, Window{...}
	c: function () {
		console.log(this.i, this); // 10, Object {...}
	}
};
obj.b();
obj.c();
```

### 使用 new 操作符

箭头函数不能用作构造器，和 `new` 一起用会抛出错误。

```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```

### 作为匿名函数

ES6 的箭头函数表达式，可以作为匿名函数的简写：
```js
// 匿名函数
let show = function () {
    console.log("匿名函数")
};
show() // "匿名函数"

let show1 = () => console.log("匿名函数");
show1(); // "匿名函数"
```

> 但是箭头函数和匿名函数在一些实际的操作中还有一些区别

### 小练习

下面代码输出结果是什么？
```js
var name = "window";

var person1 = {
	name: "person1",
	foo1: function () {
		console.log(this.name);
	},
	foo2: () => console.log(this.name),
	foo3: function () {
		return function () {
			console.log(this.name);
		};
	},
	foo4: function () {
		return () => {
			console.log(this.name);
		};
	}
};

var person2 = { name: "person2" };

person1.foo1(); // person1
person1.foo1.call(person2); // person2

person1.foo2(); // window

// foo2 返回一个箭头函数，箭头函数没有 this
person1.foo2.call(person2); // window

person1.foo3()(); // window
person1.foo3.call(person2)(); // window
person1.foo3().call(person2); // person2

person1.foo4()(); // person1
person1.foo4.call(person2)(); // person2
// 箭头函数的 this 在定义的时候就被指定了，之后改变不了
person1.foo4().call(person2); // person1
```

## 如何实现防抖和节流？

面试高频指数：★★★★☆

在实际的业务开发中，会遇到一些频繁触发的事件，比如浏览器窗口的 `resize`、`srcoll` 等，处于性能的考虑，需要减少触发数量，或者延迟触发事件的时间等，因此就用到了防抖（`debounce`）和节流（`throttle`）。

### 防抖

防抖的原理就是：用户可以尽管触发事件，但是一定在事件触发 n 秒后才执行。如果在此期间又触发了这个事件，那么就从新触发的时间点算起，n 秒后才执行。
防抖是根据延迟的时间点触发事件的。我们可以如下实现：

```js
function debounce(cb, delay = 250) {
	let timeout;
	return (...args) => {
		// 清除未到延迟时间的定时器
		clearTimeout(timeout);
		timeout = setTimeout(() => {
			// 到延迟时间执行回调函数
			cb(...args);
		}, delay);
	};
}
```

### 节流

节流是以时间段为节点，如果事件触发在这个时间段内，那么就只触发一次。
有两种实现方法：

- 使用定时器
- 使用时间戳

**使用定时器**

使用标识变量 `shouldWait`， 如果事件执行了则不再执行任何操作，否则，执行事件，并且修改标识变量 `shouldWait`。

```js
function throttle(cb, delay = 250) {
	let shouldWait = false;
	return (...args) => {
		// 如果应该等待，不执行
		if (shouldWait) return;
		// 否则，执行回调函数
		cb(...args);
		// 修改标识变量
		shouldWait = true;
		setTimeout(() => {
			// 到延迟时间之后，重新修改标识变量，确保可以开启新的节流
			shouldWait = false;
		}, delay);
	};
}
```

**使用时间戳**
计算时间范围，如果在此时间范围内，则不执行事件，否则执行事件并更新时间 `previous`。

```js
function throttle(cb, delay) {
    // 设置初始时间
    let previous = 0;
    return (...args) => {
        // 设置当前时间
        let now = +new Date();
        // 根据时间差判断是否要执行事件
        if (now - previous > delay) {
            // 如果已经超过延迟时间，执行事件
            cb(args);
            // 重置初始时间
            previous = now;
        }
    }
}
```

# 第六章Promise & Async/await & Generators

## Promise？

面试高频指数：★★★★☆

### 期约和期约链


期约是JavaScript中一种处理异步操作的机制。它是一种表示异步操作最终完成或失败的对象，可以让我们以更优雅的方式处理异步代码。

一个期约有三种状态：待定（`pending`）、已兑现（`fulfilled`）和已拒绝（`rejected`）。当一个期约被创建时，它处于待定状态。待定状态可以转变为已兑现状态或已拒绝状态，一旦转变，就不能再改变状态。

期约通过提供两个回调函数来处理异步操作的结果：`then()`和`catch()`。当期约兑现时，调用`then()`回调函数；当期约被拒绝时，调用`catch()`回调函数。

期约链（Promise chaining）是一种在多个期约之间串联处理的技术。通过将多个`then()`方法调用链接在一起，可以在一个期约完成后继续处理下一个期约的结果。

通过期约链，我们可以按顺序执行多个异步操作，并且每个异步操作的结果都可以传递到下一个操作中。这样可以更好地组织和控制异步代码，**避免回调地狱**（callback hell）

### 为什么需要Promise

为什么我们需要 Promise， 最直接的答案就是它更直观、好用。Promise 出现之前，我们使用事件和回调。我们创建并加载一个脚本文件， 监听 onload 事件， 执行对应的回调函数。如下所示：
```js
const loadScript = (src, callback) => {
	// 创建一个 <script> 标签, 并将其添加到页面
	let script = document.createElement("script");
	script.src = src;

	script.onload = () => callback(null, script);
	script.onerror = () => callback(new Error(`Script load error for ${src}`));
	document.head.append(script);
};

loadScript(
	"https://unpkg.com/vue@3/dist/vue.global.js",
	function (error, script) {
		if (error) {
			console.log(error);
		} else {
			console.log("loading Vue"); // "loading Vue"
		}
	}
);
```

此处只加载一个脚本文件，回调看起来还比较清晰，但是如果我们想加载多个脚本文件呢？如下所示：

```js
loadScript(
	"https://unpkg.com/vue@3/dist/vue.global.js",
	function (error, script) {
		console.log("loading Vue"); // "loading Vue"

		loadScript(
			"https://unpkg.com/react@18/umd/react.development.js",
			function (error, script) {
				console.log("loading React"); // "loading React"
			}
		);
	}
);
```

在上面的代码中：我们加载 Vue， 如果没有发生错误，我们加载 React......
随着调用嵌套的增加，代码层次变得更深，维护难度也随之增加，这就被称为“回调地狱”。此时 `Promise` 闪亮登场了，它可以很好地解决回调地狱问题，且代码简单易读。
如果改成 Promise：

```js
const loadScript = (src) => {
	return new Promise(function (resolve, reject) {
		let script = document.createElement("script");
		script.src = src;

		script.onload = () => resolve(script);
		script.onerror = () => reject(new Error(`Script load error for ${src}`));

		document.head.append(script);
	});
};

loadScript("https://unpkg.com/vue@3/dist/vue.global.js")
	.then((script) => {
		console.log("loading Vue"); // "loading Vue"
		return loadScript("https://unpkg.com/react@18/umd/react.development.js");
	})
	.then((script) => console.log("loading React")) // "loading React"
	.catch((error) => console.log(error));
```

### Promise 介绍

> Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。— MDN

它的构造器语法如下：
```js
let promise = new Promise(function(resolve, reject) {
    // executor 
})
```

`executor` 会自动运行并尝试执行。尝试结束后，如果成功则调用 `resolve`，如果出现 `error` 则调用 `reject`。

所以，`executor`最终将 `Promise` 移至以下状态之一：
![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode04.png)

由图可知，`new Promise` 构造器返回的 `pending` 对象具有以下内部属性：

* `state`：初始值是 `pending`，`resolve` 调用后变为 `fulfilled`, `reject` 调用之后变为 `rejected`
* `result`：初始值是 `undefined`，`resolve(value)` 调用后变为 `value`， `reject(error)` 调用时变为 `error`

Promise 支持链式调用，`.then`、`.catch` 和 `.finally `方法均支持链式调用。其中，`.then` 方法接收两个参数，第一个参数处理已决议状态（`fulfilled`）的回调函数，第二个参数则处理已经拒绝（`rejected`）的回调函数。每一个 `.then() `方法返回的是一个新生成的 `Promise` 对象，这个对象可被用作链式调用。如：
```js
const promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);
```

### 模拟实现 Promise

#### 第一版：简易版 Promise

我们的第一版 Promise 具有以下功能：

* 创建一个 Promise
* resolve 或 reject 一个 Promise，仅可敲定一次
* .then() 方法接收回调函数，满足无论 Promise 的状态是否已经敲定，都需要单独处理回调函数
* .then() 方法暂不支持链式调用，我们将在第二版实现这个功能

`MyPromise` 是一个类，它有下面三个原型方法：

* MyPromise.prototype.resolve(value)
* MyPromise.prototype.reject(reason)
* MyPromise.prototype.then(onFulfilled, onRejected)

希望可以如下使用我们实现的 `Promise`，也可作为我们稍后的测试代码:

```js
// .resolve() 先于 .then() 执行， 无论它们代码位置的先后
// .resolve() 在 .then() 前
const tp1 = new MyPromise();
tp1.resolve("abc");
tp1.then((value) => {
	console.log(value === "abc"); // true
});
// .then() 在 .resolve() 前
const tp2 = new MyPromise();
tp2.then((value) => {
	console.log(value === "def"); // true
});
tp2.resolve("def");
```

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode05.png)

```js
class MyPromise {
	// 处理 .then 中状态是 pending 的所有任务，加入任务数组中
	_fulfillmentTasks = [];
	_rejectionTasks = [];
	_preomiseResult = undefined;
	_promiseState = "pending";

	then(onFulfilled, onRejected) {
		const fulfillmentTask = () => {
			if (typeof onFulfilled === "function") {
				onFulfilled(this._preomiseResult);
			}
		};
		const rejectionTask = () => {
			if (typeof onRejected === "function") {
				onRejected(this._preomiseResult);
			}
		};
		switch (this._promiseState) {
			case "pending":
				this._fulfillmentTasks.push(fulfillmentTask);
				this._rejectionTasks.push(rejectionTask);
			case "fulfilled":
				addToTaskQueue(fulfillmentTask);
				break;
			case "rejected":
				addToTaskQueue(rejectionTask);
			default:
				throw new Error();
		}
	}

	resolve(value) {
		if (this._promiseState !== "pending") return this;
		this._promiseState = "fulfilled";
		this._preomiseResult = value;
		this._clearAndEnqueueTask(this._fulfillmentTasks);
		return this; // 可以链式调用
	}

	reject(error) {
		if (this._promiseState !== "pending") return this;
		this._promiseState = "rejected";
		thsi._promiseResult = error;
		this._clearAndEnqueueTask(this._rejectionTasks);
		return this; // 可以链式调用
	}

	_clearAndEnqueueTask(tasks) {
		this._fulfillmentTasks = undefined;
		this._rejectionTasks = undefined;
		tasks.map(addToTaskQueue);
	}
}

function addToTaskQueue(task) {
	setTimeout(task, 0);
}
```

`resolve()`

`resolve()` 方法的工作原理如下:

* 如果 Promise 已经敲定，即 Promise 已经兑现（fulfilled）或已拒绝（rejected），什么都不做。因为一个 Promise 仅可以被敲定一次。
* 改变 Promise 的状态： 由 `pending` 变为 `fulfilled`；并将结果缓存到 `this._promiseResult` 中。
* 所有的回调函数都加入队列中，用 `setTimeout()` 模拟异步执行。

`reject()`

原理同 `resolve()`，只不过它处理的是 Promise 的 `rejected` 情况。

`then()`

`then()` 方法需要处理下面两种情况:

* 如果 Promise 是 `pending` 状态，需要把它封装成待处理的函数： `onFulfilled` 和 `onRejected`，添加到对应的任务数组中（`_fulfillmentTasks` 和 `_rejectionTasks`），它们将在 Promise 已经敲定后再执行。
* 如果 Promise 已经敲定，`onFulfilled`、`onRejcted `可以直接触发。

Promise 必须始终是异步敲定，这就是我们为什么不直接执行` task`，而是添加到事件循环（`event loop`）的任务队列中。真正的 Promise 不是使用 `setTimeout `模拟的，它使用的是微任务（microtasks）。

#### 第二版：实现链式调用

我们将实现链式调用，先看一段代码：
```js
new MyPromise()
	.resolve("result1")
	.then((x) => {
		console.log(x === "result1"); // true
		return "result2";
	})
	.then((x) => {
		console.log(x === "result2"); // true
		return new Error("error1");
	})
	.then((x) => {
		console.log(x.message === "error1"); // true
	});
```

在上面的例子中：

* 第一个 `.then()` 方法在传递了一个箭头函数，返回一个值 `result2`
* 第二个 `.then()` 方法在中接收了 `result2`

`.then()` 方法如何实现链式调用呢？

* `.then()` 返回一个 Promise，无论前一个 Promise 返回的是 `onFullfilled` 还是 `onRejected`，它都接收其状态。
* 如果 `onFulfilled` 或 `onRejected` 都缺失，都通过 `.then()` 方法返回给该 Promise。

下面的图更为直观:

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode06.png)

```js
then(onFulfilled, onRejcted) {
    const resultPromise = new MyPromise(); // new

    const fulfillmentTask = () => {
        if (typeof onFulfilled === "function") {
            const returned = onFulfilled(this._preomiseResult);
            resultPromise.resolve(returned);
        } else {
            resultPromise.resolve(this._promiseResult); // new
        }
    };

    const rejectionTask = () => {
        if (typeof onRejected === "function") {
            const returned = onRejected(this._promiseResult);
            resultPromise.resolve(returned); // new
        } else {
            resultPromise.reject(this._promiseResult);
        }
    };

    // ...
    return resultPromise; // new
}
```

`.then()` 返回一个新的 Promise，此外，我们需要关注：

* `fulfillmentTask` 会有两种不同表现：
  * 如果提供了 `onFullfilled` 函数，调用它并将其结果传递给 `resultPromise` 的 `resolve` 方法。
  * 如果没提供，使用当前 Promise 的敲定结果 `this._promiseResult` 传递给 `resultPromise` 的 `resolve` 方法。
* `rejectionTask` 也有两种表现：
  * 如果提供了 onRejected 函数，调用它并将其结果传递给` resultPromise `的` resolve` 方法。注意：`resultPromise `并没有被拒绝，我们将在后文详细解释。
  * 如果没提供，使用当前 Promise 的敲定结果 `this._promiseResult` 传递给 `resultPromise` 的 `resolve` 方法。

#### 第三版：处理 thenable

thenable 是一个对象，它具有方法 `.then`，被当作一个 Promise 对待。`then() `方法中还可以创建并返回一个 `Promise`，在这种情况下，其他的处理程序将等待它被敲定后再获得其结果。
```js
asyncFunc1()
.then((result1) => {
    console.log(result1 === "Result of asyncFun1()"); // true
    return asyncFunc2(); // A
})
.then((result2Promise) => {
    result2Promise
        .then((result2) => {  // B
            console.log(result2 === "Result of asyncFun2"); // true
        })
})处。
```

在 A 处，如果返回了一个 Promise，然后在第二个 `.then() `中作为参数传入，并敲定了这个 Promise。官方的 Promise 可以直接敲定嵌套的 Promise，如下面的代码：
```js
asyncFunc1()
.then((result1) => {
    console.log(result1 === "Result of asyncFun1()"); // true
    return asyncFunc2(); // A
})
.then((result2) => {
    // result2 是一个已兑现的结果，而非 Promise
    console.log(result2 === "Result of asyncFun2"); // true
})
```

我们将这样处理 `then()` 方法中返回的 thenable，如下图:

* 如果第一个 Promise 处理的是一个 thenable 对象 x1，它锁定 x1 并且用 x1 敲定的结果作为敲定结果。
* 如果第一个 Promise 处理的不是 thenable 对象，则像之前一样。

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode07.png)

我们可以这样判断 thenable 对象：
```js
function isThenable(value) {
	return (
		typeof value === "object" &&
		value !== null &&
		typeof value.then === "function"
	);
}
```

我们再来完善 `.resolve()` 方法:
```js
resolve(value) {
    if (this._alreadyResolved) return this;
    this._alreadyResolved = true;

    if (isThenable(value)) {
        value.then(
            (result) => this._doFulfill(result),
            (error) => this._doReject(error);
        )
    } else {
        this._doFulfill(value);
    }

    return this; 
}

_doFulfill(value) { // [new]
    console.log(!isThenable(value)) // true
    this._promiseState = "fulfilled";
    this._promiseResult = value;
    this._clearAndEnqueueTasks(this._fulfillmentTasks);
}
```

this._alreadyResolved 是为了锁定 Promise 的状态的。返回一个已敲定状态的 Promise，那么 then() 返回的 Promise 的状态也会是已敲定。返回已拒绝状态同理。

#### 第四版：处理错误

我们希望错误也能够得到正确处理：
```js
new MyPromise()
  .resolve("a")
  .then((value) => {
    console.log(value === "a"); // true
    throw "b"; // 抛出一个错误
  })
  .catch((error) => {
    console.log(error === "b"); // true
  })
```

如果我们要处理错误，只需要在 `.then()` 方法中添加相关代码即可：
```js
const fulfillmentTask = () => {
    if (typeof onFulfilled === "function") {
        this._runReactionSafely(resultPromise, onFulfilled); // [new]
    } else {
        // `onFulfilled` 没有传
        // => 我们需要传已敲定的结果
        resultPromise.resolve(this._promiseResult);
    }  
};

_runReactionSafely(resultPromise, reaction) { // [new]
    try {
        const returned = reaction(this._promiseResult);
        resultPromise.resolve(returned);
    } catch (e) {
        resultPromise.reject(e);
    }
}
```

错误处理过程如图所示:

![](https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode08.png)

### 总结

至此，我们模拟实现了 Promise，包含 `.then()`、`.resolve()`、 `.reject()` 方法的实现。

```js
class MyPromise {
	_fulfillmentTasks = [];
	_rejectionTasks = [];
	_promiseResult = undefined;
	_promiseState = "pending";
	_alreadyResolved = false;

	then(onFulfilled, onRejected) {
		const resultPromise = new MyPromise();

		const fulfillmentTask = () => {
			if (typeof onFulfilled === "function") {
				this._runReactionSafely(resultPromise, onFulfilled);
			} else {
				resultPromise.resolve(this._promiseResult);
			}
		};

		const rejectionTask = () => {
			if (typeof onRejected === "function") {
				this._runReactionSafely(resultPromise, onRejected);
			} else {
				resultPromise.reject(this._promiseResult);
			}
		};

		switch (this._promiseState) {
			case "pending":
				this._fulfillmentTasks.push(fulfillmentTask);
				this._rejectionTasks.push(rejectionTask);
				break;
			case "fulfilled":
				addToTaskQueue(fulfillmentTask);
				break;
			case "rejected":
				addToTaskQueue(rejectionTask);
				break;
			default:
				throw new Error();
		}
		return resultPromise;
	}

	catch(onRejected) {
		return this.then(null, onRejected);
	}

	_runReactionSafely(resultPromise, reaction) {
		try {
			const returned = reaction(this._promiseResult);
			resultPromise.resolve(returned);
		} catch (e) {
			resultPromise.reject(e);
		}
	}

	resolve(value) {
		if (this._alreadyResolved) return this;
		this._alreadyResolved = true;

		if (isThenable(value)) {
			value.then(
				(result) => this._doFulfill(result),
				(error) => this._doReject(error)
			);
		} else {
			this._doFulfill(value);
		}

		return this;
	}

	_doFulfill(value) {
		this._promiseState = "fulfilled";
		this._promiseResult = value;
		this._clearAndEnqueueTasks(this._fulfillmentTasks);
	}

	reject(error) {
		if (this._alreadyResolved) return this;
		this._alreadyResolved = true;
		this._doReject(error);
		return this;
	}

	_doReject(error) {
		this._promiseState = "rejected";
		this._promiseResult = error;
		this._clearAndEnqueueTasks(this._rejectionTasks);
	}

	_clearAndEnqueueTasks(tasks) {
		this._fulfillmentTasks = undefined;
		this._rejectionTasks = undefined;
		tasks.map(addToTaskQueue);
	}
}

function isThenable(value) {
	return (
		typeof value === "object" &&
		value !== null &&
		typeof value.then === "function"
	);
}

function addToTaskQueue(task) {
	setTimeout(task, 0);
}
```

### 小练习

如何使用 Promise 封装 XMLHttpRequest?

```js
function load(url) {
	return new Promise(function (resolve, reject) {
		const request = new XMLHttpRequest();
		request.onreadystatechange = function () {
			if (this.readyState === 4 && this.status == 200) {
				resolve(this.response);
			} else {
				reject(this.status);
			}
		};
		request.open("GET", url, true);
		request.send();
	});
}

// test
load("testUrl")
	.then((response) => {
		const result = JSON.parse(response);
		// ...
	})
	.catch((error) => {
		// ...
	});
```

## ES6 中的 Iterator 和 Iterable

面试高频指数：★★☆☆☆

JavaScript 提供对数据迭代的协议。迭代协议具体分为两个协议：

- 可迭代协议（iterable protocol）
- 迭代器协议（iterator protocol）

### 可迭代协议

可迭代协议允许 JavaScript 对象定义或定制它们的迭代行为，例如，在一个 `for..of` 结构中，哪些值可以被遍历到。

要成为可迭代对象，该对象必须实现` @@iterator` 方法，可通过常量 `Symbol.iterator]` 访问该属性，它的返回值为一个符合迭代器协议的对象。

### 迭代器协议.

`[Symbol.iterator]` 返回的对象就是一个迭代器对象。它提供 `next()` 方法，返回一个具有以下属性的对象：

* `value`：迭代器返回的任何 JavaScript 值。`done` 为`true `时可省略。
* `done`：迭代器能否返回下一个值，不能则为` false`， 否则为` true`。

我们可以这样理解，一个可迭代对象实现了一个接口，询问两个问题：

- 还有剩余的元素吗？
- 如果有，剩余的元素是什么？

### 内置的可迭代对象

* `String`、`Array`、`TypedArray`、`Map`、`Set `都是内置的可迭代对象，因为它们的每个 `prototype` 对象都实现了 `@@iterator`方法。
* `arguments` 对象和一些 `DOM` 集合类型，如 `NodeList` 也是可迭代的。目前，没有内置的异步可迭代对象.
* 生成器函数（`generator`）返回生成器对象，它们是可迭代的迭代器。

### 对象是否可迭代？

`Object` 是不可迭代的，如下面的代码：

```js
const people = {
  name: 'John Doe',
  age: 13,
  sex: 'male',
  born: 1994
};

for (const p of people) {
  console.log(p); // Uncaught TypeError: people is not iterable
}
```

我们可以给对象添加 `Symbol.iterator`，使其可迭代，但这个不是最佳方案。我们可以使用 `Object.entires()` 或使用 `Map`。
`Object.entires()`

```js
Object.entries(people); // [['name', 'John Doe'], ['age', 13], ['sex', 'male'], ['born', 1994]]
```

`Map`

```js
const people = {
  name: 'John Doe',
  age: 13,
  sex: 'male',
  born: 1994
};

const buildMap = obj =>
  Object.keys(obj).reduce((map, key) => map.set(key, obj[key]), new Map());

const map = buildMap(people);

map.get('name') // John Doe
map.get('age'); // 13
```

### 实现一个迭代器

由上可知，实现一个迭代器，我们要做两步：

* 实现可迭代协议，如下面代码 A 处。
* 实现迭代器协议，如下面代码 B 处。

```js
class MyIterator {
  constructor(params) {
    this.index = 0;
    this.value = params;
  }
  [Symbol.iterator]() {
    return this; // A
  }
  next() { // B
    return {
      value: this.value[this.index++],
      done: this.index > this.value.length ? true : false,
    };
  }
}

let it = new MyIterator(["a", "b", "c"]);
console.log(it.next()); // { value: "a", done: false }
console.log(it.next()); // { value: "b", done: false }
console.log(it.next()); // { value: "c", done: false }
console.log(it.next()); // { value: undefined, done: true }
console.log(it.next()); // { value: undefined, done: true }
```

## 生成器

面试高频指数：★★☆☆☆

常规函数只会返回一个单一值（或者不返回值），而 ES6 的`generator` 可以按需一个接一个地返回（`yield`）多个值。

JavaScript 中的函数是不可暂停的，`generator` 函数则可以暂停：

```js
function* generate() {
	console.log("invoked 1st time"); // "invoked 1st time"
	yield 1;
	console.log("invoked 2nd time"); // // "invoked 2nd time"
	yield 2;
}
let gen = generate();
console.log(gen); // Object [Generator] {}

let result = gen.next(); 
console.log("result", result); // {value: 1, done: false}
```

我们分析一下上面的代码：

* `*` 号在函数前面，代表这是个 `generator` 函数.
* `yield` 表达式返回一个值，并且暂停这个函数的执行.
* `generate()` 调用后，返回一个 `Generator` 对象，还没有执行它的函数体的部分。
* 调用 `Generator` 对象上的 `next()` 方法，执行函数体的内容，遇到 `yield` 返回 `1` 并且暂停 `generator` 函数。

### `next()` 方法

`generator` 的主要方法就是 `next()`，它是一个具有两个属性的对象：

- `value`: 产出的（`yielded`）的值。
- `done`: 如果 `generator` 函数已执行完成则为 `true`，否则为 `false`。

### `yield`

当调用 `next()` 方法的时候，`yield` 将返回值添加到对象的 `value` 属性上。

```js
function* foo() { 
    yield 1;
    yield 2;
    yield 3;
}

let f = foo();
console.log(f.next()); // { value: 1, done: false }
```

### `yield*`

`yield*` 表达式迭代操作数，并产生它返回的每个值。我们可以使用 `yield*` 返回数组的每个元素：

```js
function* yieldArrayElements() {
    yield 1;
    yield* [ 20, 30, 40 ];
}

let a = yieldArrayElements();

console.log(a.next()); // { value: 1, done: false }
console.log(a.next()); // { value: 20, done: false }
console.log(a.next()); // { value: 30, done: false }
console.log(a.next()); // { value: 40, done: false }
```

### `generator` 是可迭代的

ES6 中 `for...of` 可以遍历：

* `Array`、`String`、`Map`
* `Array-like` 对象，比如 `arguments` 或者 `NodeList`

- 用户定义的对象，实现了可迭代接口的。

```js
let str = 'abc';
for (let c of str) {
    console.log(c);
}
//输出
//a
//b
//c
```

同样，我们也可以使用 `for...of` 循环遍历 `generator` 所有的值。如下示例：

```js
function* generate() {
	console.log("invoked 1st time"); // "invoked 1st time"
	yield 1;
	console.log("invoked 2nd time"); // "invoked 2nd time"
	yield 2;
}
let gen = generate();
console.log(gen); // Object [Generator] {}

// for...of
for (const g of gen) {
	console.log("for...of g", g); 
}
//输出
//"invoked 1st time"
//"for...of g" 1
//"invoked 2nd time"
//"for...of g" 2
```

### 小练习

下面代码的输出结果是什么？
```js
const arr = ['a', 'b', 'c'];

function* generator() {
    yield 1;
    yield* arr;
    yield 2;
}

for (let value of generator()) {
    console.log(value)
}
//依次输出 1、a、b、c、2
```

## async/await

面试高频指数：★★★☆☆

### `async/await` 定义

`async/await` 实际上是 Promise 的语法糖，它可以用一种更舒适的方式使用 Promise，更易于理解和使用。

`async` 关键字放在函数前面，表达这个函数总是返回一个 Promise，其他值将自动被包装在一个` resolved` 的 Promise 中。

```js
async function f() {
    return 1;
}

f().then((v) => console.log(v));

console.log('f', f())
```

`await `关键字可以暂停函数的执行，直到 Promise 的状态变成已敲定，然后 Promise 的结果继续执行。相比于` promise.then`，它显得更为优雅。如果在非 `async` 中使用，会报语法错误。

```js
async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // 等待，直到 promise resolve (*)

  alert(result); // "done!"
}

f();
```

### 错误处理

如果一个 Promise 正常 `resolve`，`await promise` 的结果就是其返回值，否则，将抛出错误。我们可以使用 `try/catch` 来捕获错误。

```js
async function f() {
  try {
    let response = await new Promise((resolve, reject) => {
        throw new Error('test err')
    });
  } catch(err) {
    console.log(err); // Error: test err
  }
}

f();
```

### 小练习

如何使用 `async` 实现 `delay` 函数, `delay` 函数定义如下：

```js
delay((str) => str, 3000, 'Hello world').then(res => console.log(res))
```

答案：参考代码如下：

```js
const sleep = (cb, time, args) => ({
	then: (cb) => {
		setTimeout(() => cb(args), time);
	}
});

const delay = async (cb, time, args) => {
	return await sleep(cb, time, args);
};

delay((str) => str, 3000, "Hello world").then((res) => console.log(res)); // Hello world
```

## 如何实现红绿灯效果？

面试高频指数：★★★☆☆

红绿灯题目：实现一个信号灯，这个信号灯，有黄绿红，他们各自亮灯的持续时间是 1s，2s，3s 如此反复。

这道题考查的是对 Promise 和 async/await 的应用。

```js
function delay(fn, time) {
	return new Promise((resolve) => {
		setTimeout(() => {
			resolve(fn()); // A
		}, time);
	});
}

async function light() {
	await delay(() => console.log("red"), 3000);
	await delay(() => console.log("green"), 2000);
	await delay(() => console.log("yellow"), 1000);
	await light();
}

light();
```

* `light()` 是一个带有 `async` 关键字的函数，代表这是个异步函数。
* `await` 函数接收一个 `Promise`，并且等待 `Promise` resolve 之后再继续执行后续代码。
* `delay()` 函数是我们创建的一个返回 Promise 的函数，这个函数在指定时间后异步调用回调函数，注意代码 A 处.

# 第七章 模块

## 模块化的发展历程

面试高频指数：★★★★☆

### 模块化的定义

**一个模块（module）就是一个文件。一个脚本就是一个模块。**

模块可以相互加载，并可以使用特殊的指令 `export` 和 `import` 来交换功能，从另一个模块调用一个模块的函数：

* `export` 关键字标记了可以从当前模块外部访问的变量和函数。

- `import` 关键字允许从其他模块导入功能。

### 模块化的历程

大致可以分为三个阶段：

- 早期模块化方案
- 规范标准时代
- ES6 模块

#### **早期模块化方案**
**命名空间**

对象可以有属性，对象的属性通过对象名字来访问，相当于设定了一个命名空间。

```js
var myModule = {
	name: "Joe",
	getName: function () {
		console.log(this.name); 
	}
};

myModule.getName(); // "Joe"
```

然而缺点是，对象内部属性全部会暴露出来，内部状态可以被外部更改，如下：

```js
var myModule = {
	name: "Joe",
	getName: function () {
		console.log(this.name); 
	}
};
myModule.name = "Lucy";
myModule.getName(); // "Lucy"
```

**立即执行函数 IIFE**

立即执行函数（简称 IIFE）是利用函数闭包的特性来实现私有数据和共享方法，如下：
```js
var myModule = (function () {
	var name = "Joe";
	function getName() {
		console.log(name);  
	}

	return { getName };
})();

myModule.name = "哈哈哈";
myModule.getName(); // "Joe"
```

我们可以看到，这种方法很好实现了数据的封装和私有化。如果依赖另外一个模块呢？我们只需要将其他模块作为参数传入：

```js
// otherModule.js 模块文件
var otherModule = (function () {
	return {
		a: 1,
		b: 2
	};
})();

// myModule.js模块文件 - 依赖 otherModule 模块
var myModule = (function (other) {
	var name = "Joe";
	function getName() {
		console.log(name);
		console.log(other.a, other.b);
	}

	return { getName };
})(otherModule);

myModule.name = "哈哈哈";
myModule.getName(); // 依次输出："Joe" 1 2
```

#### 规范标准时代

主要有四种规范：

* `CommonJS` —— 为 `Node.js` 创建的模块系统。
* `AMD` —— 最古老的模块系统之一，最初由 `require.js` 库实现。
* `CMD` —— 它汲取了 `CommonJS` 和 `AMD` 规范的优点，也是专门用于浏览器的异步模块加载
* `UMD` —— 另外一个模块系统，建议作为通用的模块系统，它与 `AMD` 和 `CommonJS` 都兼容。

`CommonJS`

在 `Node.js` 中，每一个文件就是一个模块，具有单独的作用域，对其他文件是不可见的。关于 `CommonJS` 的规范有几个需要注意的特点：

* 文件即模块，文件内所有代码都运行在独立的作用域，因此不会污染全局空间。
* 模块可以被多次引用、加载。在第一次被加载时，会被缓存，之后都从缓存中直接读取结果。
* 加载某个模块，就是引入该模块的 `module.exports` 属性。
* `module.exports` 属性输出的是值的拷贝，一旦这个值被输出，模块内再发生变化不会影响到输出的值。
* 模块加载顺序按照代码引入的顺序。
* 注意 `module.exports` 和 `exports` 的区别

`CommonJS` 规范用代码如何在浏览器端实现呢？其实就是实现 `module.exports` 和 `require` 方法。

实现思路：根据 require 的文件路径，加载文件内容并执行，同时将对外接口进行缓存。因此我们需要定义module.exports 后，借助立即执行函数，将 module 和 module.exports 对象进行赋值：

```js
let module = {}
module.exports = {}

(function(module, exports) {
    // ...  
}(module, module.exports))
```

`AMD`

Asynchronous module definition (AMD) 是专门为浏览器环境设计的，它定义了一套异步加载标准来解决同步的问题。它规定了如何定义模块，如何对外输出，如何引入依赖。这一切都需要代码去实现，因此一个著名的库 —— require.js 应运而生，require.js 实现很简单：通过` define `方法，将代码定义为模块；通过 `require` 方法，实现代码的模块加载。

`CMD`

`CMD` 规范整合了 `CommonJS` 和` AMD` 规范的特点。它的全称为：Common Module Definition，类似 require.js，`CMD` 规范的实现为 sea.js。
`AMD` 和` CMD` 的两个主要区别如下。

* AMD 需要异步加载模块，而 CMD 在 require 依赖的时候，可以通过同步的形式（require），也可以通过异步的形式（require.async）。
* CMD 遵循依赖就近原则，AMD 遵循依赖前置原则。也就是说，在 AMD 中，我们需要把模块所需要的依赖都提前在依赖数组中声明。而在 CMD 中，我们只需要在具体代码逻辑内，使用依赖前，把依赖的模块 require 进来。

具体到代码实现，sea.js 与 require.js 并没有本质差别，这里不再另做分析。

`UMD`

UMD（Universal Module Definition），即通用模块定义。它随着大前端的趋势所诞生，可以通过运行时或者编译时让同一个代码模块在使用`CommonJS`、`CMD `甚至是 `AMD` 的项目中运行，也就是说同一个 JavaScript 包运行在浏览器端、服务区端甚至是 APP 端都只需要遵守同一个写法就行了，那它是怎样实现的呢？

```js
((root, factory) => {
	if (typeof define === "function" && define.amd) {
		// AMD
		define(factory);
	} else if (typeof exports === "object") {
		// CommonJS
		module.exports = factory();
	} else if (typeof define === "function" && define.cmd) {
		// CMD
		define(function (require, exports, module) {
			module.exports = factory();
		});
	} else {
		// 都不是
		root.umdModule = factory();
	}
})(this, () => {
	console.log("我是UMD"); // "我是UMD"
	// todo...
});
```

可以看到，`define` 是 `AMD/CMD` 语法，而 `exports` 只在 `CommonJS` 中存在，你会发现它在定义模块的时候会检测当前使用环境和模块的定义方式，如果匹配就使用其规范语法，全部不匹配则挂载在全局对象上，我们看到传入的是一个` this`，它在浏览器中指的就是 `window`，在服务端环境中指的就是 `global`，使用这样的方式将各种模块化定义都兼容。

#### ES6 模块

ES6 模块（或称为 ESM），ES6 模块不是对象，`import `命令被 JavaScript 引擎静态分析，在编译的时候就引入模块代码。而不是在代码运行时加载，所以无法实现条件加载。也就使得静态分析成为可能。

`export`

`export` 可以导出对象中多个属性、方法，`export default` 只能导出一个可以不具名的函数。我们可以使用 `import` 引入。

`import`

```js
import { fn } from './xxx' // export 导出的方式

import fn from 'xx' // export default 方式
```

ES6 模块运行机制与 CommonJS 运行机制不一样。JavaScript 引擎对脚本静态分析的时候，遇到模块加载指令后会生成一个只读引用。等到脚本真正执行的时候。才会通过引用模块获取值，在引用到执行的过程中，模块中的值发生变化，导入的这里也会跟着发生变化。ES6 模块是动态引入的。并不会缓存值。模块里总是绑定其所在的模块。

# 第八章

## Object.defineProperty 与 Proxy 的区别？

面试高频指数：★★★☆☆

要谈两者区别，我们先来了解一下 `Objet.defineProperty()` 和 `Proxy`。

### `Objet.defineProperty()`

`Objet.defineProperty()` 可以定义一个对象的属性或修改对象上已存在的属性，并返回这个对象。语法如下：

```js
Object.defineProperty(obj, prop, descriptor);
```

我们来了解一下第三个参数 `descriptor`。它是属性描述符，MDN 中描述如下：

> 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。

数据描述符和存取描述符共享两个可选键值：

* `configurable`：当值为 `true `时，该属性的描述符才能被改变，默认为 `false`
* `enumerable`：当值为 `true `时，该属性才会出现在对象的枚举属性中，默认为 `false`

除上面两个属性外，数据描述符具有下面两个可选键值：

- `value`：该属性对应的值。默认为 `undefined`
- `writable`： 当值为 `true` 时，上面的 `value` 才能被修改，默认为 `false`

存取描述符具有下面两个可选键值：

* `get`：属性的 `getter` 函数，当访问该属性时，会调用此函数。如无 `getter`，则为 `undefined`
* `set`：属性的 `setter` 函数，但属性值被修改时，会调用该函数。如无` setter`，则为 `undefined`

总的来说，数据描述符和存取描述符可拥有的键值概括如下：

|            | configurable | enumerable | value  | writable | get    | set    |
| ---------- | ------------ | ---------- | ------ | -------- | ------ | ------ |
| 数据描述符 | 可以         | 可以       | 可以   | 可以     | 不可以 | 不可以 |
| 存取描述符 | 可以         | 可以       | 不可以 | 不可以   | 可以   | 可以   |

#### 拦截对象属性

此处，`descriptor` 我们使用 `get` 和 `set` 方法拦截对象的属性：

```js
let o = {};
let value = "value";

Object.defineProperty(o, "b", {
	get() {
		// 获取 o.b 的值
		console.log(`get ${value}`);
		return value;
	},
	set(newValue) {
		// 设置 o.b 的值
		console.log(`set ${newValue}`);
		value = newValue;
	},
	enumberable: true,
	configurable: true
});

// 获取对象 o 的属性 b 的值
console.log(o.b);
// 依次输出：
// "get value"
// "value";

// 设置对象 o 的属性 b 的值为 value1
o.b = "value1"; // "set value1"

// 重新获取对象 o 的属性 b 的值
console.log(o.b);
// 依次输出：
// "get value1"
// "value1"

delete o.b; // 删除属性, 未触发 get、set 操作

console.log(o.b); // undefined
```

从上面的代码可以看出，我们通过 get 和 set 方法，可以检测到对象属性的变化，从而实现对象属性的监听。然而删除属性操作却并未触发 get 和 set 方法。

#### 监听对象上的多个属性

如果我们监听对象上的多个属性的变化，就需要遍历对象：
```js
let list = [1, 2, 3];

list.map((elem, index) => {
	Object.defineProperty(list, index, {
		get: function () {
			console.log("get index:" + index);
			return elem;
		},
		set: function (val) {
			console.log("set index:" + index);
			elem = val;
		}
	});
});

list[2] = 6; // 输出 "set index:2"
console.log(list[1]); // 依次输出: "get index:1" 2
list.push(4); // A 无输出
list[3] = 5; // B 无输出
console.log(list[3]); // 输出 5
list.length = 10; // C 无输出
```

虽然我们监听到了数组的变化，但是代码 A、B、C 处理想情况下，我们希望它触发` set `操作，但此处并没有输出。因此，操作数组的 `push` 方法、修改数组长度 `length` 都无法监听到正确结果。

数组的方法我们可以通过劫持` Array.prototype` 上的方法做到：
```js
const arrayMethods = [
	"push",
	"pop",
	"shift",
	"unshift",
	"splice",
	"sort",
	"reverse"
];

const arrayProto = Object.create(Array.prototype);

arrayMethods.forEach((method) => {
	const origin = Array.prototype[method];
	arrayProto[method] = function () {
		console.log("run method", method);
		return origin.apply(this, arguments);
	};
});

const list = [];
list.__proto__ = arrayProto;

list.push(2); // "run method" "push"
list.shift(3); // "run method" "shift"
```

#### `Object.defineProperty` 的缺陷

由上可知，Object.defineProperty 在劫持对象和数组时的缺陷：

* 无法检测到对象属性的添加或删除
* 监听对象的多个属性，需要遍历该对象
* 无法检测数组元素的变化，需要进行数组方法的重写
* 无法检测数组的长度的修改

### Proxy

MDN 对 `Proxy` 的定义如下：

> `Proxy` 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。

它的语法如下：
```js
cosnt p = new Proxy(target, handler)
```

它的两个参数：

* `target`：需要代理的目标对象，可以是任何类型的对象，包括原生数组，函数，甚至另一个代理
* `handler`：一个以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。

这里列举几个 `handler`:

* `handler.get(target, property, receiver)`：设置属性的捕捉器
  * `target`：是目标对象
  * `property`：是目标属性名
  * `receiver`: 如果目标属性是一个` getter` 访问器属性，则` receiver` 就是本次读取属性所在的 `this` 对象。

* `handler.set(target, property, value, receiver)`：读取属性的捕捉器，如果写入成功，返回 `true`，否则返回 `false`

  - `target`：目标对象

  - `property`：目标对象的属性

  - `value`：目标对象属性的值

  - `receiver`：同 `get` 捕捉器

* `handler.defineProperty()` ：方法的捕捉器

* `handler.has()`：in 操作符的捕捉器

* `hander.apply()`：函数调用的捕捉器

上文我们使用 `Object.defineProperty` 拦截对象的属性和方法，这里也可以使用 `Proxy` 来实现：
```js
let o = {};
let value = 'value';

// 使用 Proxy 创建 对象 o 的代理对象 p
let p = new Proxy(o, {
    get(target, property) {
        // 获取对象 o 上的属性，有则返回该属性的值，如果没有则返回变量 value
        return property in target ? target[property] : value;
    },
    set(target, property, value) {
        // 设置对象 p 的 value
        target[property] = value;
        return true;
    },
	deleteProperty: function (target, propKey) {
		// 删除对象 p 上的属性
		console.log(`delete ${propKey}!`);
		delete target[propKey];
		return true;
	}
});

// 获取对象 p 的属性 value 的 value
console.log(p.value); // "value";

// 设置对象 p 的属性 b 的值为 value1
p.b = 'value1'; // "value1"
console.log(p.b); // "value1"

// 对象 o 的方法也被改变了
console.log(o.value); // undefined
console.log(o.b); // "value1"

delete p.b; // "delete b!"
console.log(o.b); // "undefined"
```

可以看到，`Proxy` 直接代理了 `target` 整个对象，并且返回了一个新的对象；能监听到属性的增加、删除操作。

`Proxy` 还能代理数组：

```js
let numbers = [];

let p = new Proxy(numbers, { 
  set(target, prop, val) { // 拦截写入属性操作
    if (typeof val == 'number') {
      target[prop] = val;
      return true;
    } else {
      return false;
    }
  }
});

numbers.push(1); // 添加成功
numbers.push(2); // 添加成功
console.log("Length is: " + p.length, numbers.length); // Length is: 2 2
numbers.push("test"); // TypeError（proxy 的 'set' 返回 false）
console.log("p is: " + p); // p is: 1,2,test
console.log("numbers is: " + numbers);  // numbers is: 1,2,test
```

数组的长度变化以及方法` push` 都能够被监听到，而且除了除了常用的 `get`、`set `操作外，`Proxy `更是支持 13 种拦截操作，上面只列出了部分，剩余的可以去 MDN 上查阅。

#### Proxy 中的 `this`

`Proxy` 中虽然完成了对目标对象的代理，但是即使 `handler` 为空对象，它代理的对象中的 `this` 指向的是代理对象，而不是目标对象。

```js
let target = {
    m() {
        // 检查 this 的指向是不是 proxyObj
        console.log(this === proxyObj)
    }
}
let handler = {}
let proxyObj = new Proxy(target, handler)

proxyObj.m() // 输出: true
target.m() //输出: false
```

### 总结

由上可知，`Object.defineProperty` 与 `Proxy` 的区别如下：

|                      | Object.defineProperty | Proxy                           |
| -------------------- | --------------------- | ------------------------------- |
| 定义                 | 代理对象某个属性      | 代理整个对象                    |
| 对象新增属性         | ❌                     | ✅                               |
| 数组新增修改和length | ❌                     | ✅                               |
| this                 | 指向目标对象          | 指向代理对象                    |
| 兼容性               | 兼容IE                | 不兼容IE8及以下                 |
| 使用上               | 考虑因素多            | 更方面，方法多（13种`handler`） |

## Reflect

面试高频指数：★★☆☆☆

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与 Proxy 的 handler 的方法相同。Reflect 的所有属性和方法都是静态的（就像 Math 对象）。

### Reflect 有什么用？

`Reflect` 对象上挂载了很多静态方法，它有一些对应的函数或功能符，如下表：

| 静态方法                           | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| `Reflect.apply`                    | 对函数进行调用操作，同时传入一个数组作为调用参数，与 `Function.prototype.apply` 功能类似 |
| `Reflect.construct`                | 对构造函数进行 `new` 操作，相当于执行 `new target(...args)`  |
| `Reflect.construct`                | 对构造函数进行 `new` 操作，相当于执行 `new target(...args)`  |
| `Reflect.deleteProperty`           | 作为函数的 `delete` 操作符，相当于执行 `delete target[name]` |
| `Reflect.get`                      | 获取对象属性值                                               |
| `Reflect.getOwnPropertyDescriptor` | 类似于 `Object.getOwnPropertyDescriptor`                     |
| `Reflect.getPrototypeOf`           | 类似于 `Object.getPrototypeOf`                               |
| `Reflect.has`                      | 判断对象是否存在某个属性，和 `in` 运算符的功能完全相同       |
| `Reflect.isExtensible`             | 类似于 `Object.isExtensible`                                 |
| `Reflect.ownKeys`                  | 返回一个包含所有自身属性（不包含继承属性）的数组             |
| `Reflect.preventExtensions`        | 类似于 `Object.preventExtensions`                            |
| `Reflect.set`                      | 将值分配给属性的函数，返回 `Boolean`，如果成功，则返回 `true` |
| `Reflect.setPrototypeOf`           | 类似于 `Object.setPrototyeOf`                                |

我们可以使用 `Reflect` 操作数组：

```js
const arr1 = [];
Reflect.set(arr1, 0, 'first');
Reflect.set(arr1, 1, 'second');
Reflect.set(arr1, 2, 'third');
console.log(arr1); // ["first","second","third"]
```

我们还可以搭配 `Proxy` 使用：
```js
let obj = {};
const proxy = new Proxy(obj, {
	get(target) {
		console.log("get name");
		return Reflect.get(target, name);
	},
	deleteProperty(target, name) {
		console.log("delete" + name);
		return Reflect.deleteProperty(target, name);
	}
});

proxy.name = "Joe"; 

console.log(proxy.name);

delete proxy.name;
```

### 返回值

如果我们把 `obj` 的 `name` 改为可读，`configurable` 默认是 `false`，因此只设置 `get` 方法：
```js
let obj = {}

Object.defineProperty(obj, name, {
	get () {
		return "Joe"
	},
    // configurable: false
});

console.log(obj.name = "Lily1"); // "Lily1"

console.log(Reflect.set(obj, name, "Lily")) // false
```

可以看到，`Relfect` 可以知道属性是否设置成功，而 `Object.defineProperty` 则不可以。

### `Reflect` 的第三个参数 `receiver`

receiver 是接收者的意思，表示调用对应属性或方法的主体对象，通常情况下，receiver 无需传递，但是如果发生了继承，则需要明确调用主体，需要使用 receiver。

```js
let cat = {
	_name: '中华田园猫',
	get name () {
		return this._name
	}
}

let baiMao = new Proxy(cat, {
	get (target, prop) {
		return target[prop];
	}
})

let xiaoBai = {
	__proto__: baiMao,
	_name: "小白"
}

console.log(xiaoBai.name); // "中华田园猫"
```

此处，我们希望输出结果是 `"小白"`，应该传递 `receiver`：
```js
let cat = {
	_name: '中华田园猫',
	get name () {
		return this._name
	}
}

let baiMao = new Proxy(cat, {
	get (target, prop, receiver) {
		return Reflect.get(target, prop, receiver); // A
	}
})

let xiaoBai = {
	__proto__: baiMao,
	_name: "小白"
}

console.log(xiaoBai.name); // "小白"
```

注意代码 A 处，我们使用 `Reflect` 并且传递了 `receiver`。

### `Reflect` 与传统方法的对比

|            | Reflect                                     | **传统方法操作对象**                 |
| ---------- | ------------------------------------------- | ------------------------------------ |
| 面向对象   | 方法都在 `Relfect` 对象上，更加符合面向对象 | 各种指令方法： `=`、 `in`、 `delete` |
| 返回值不同 | 获取操作结果，不会因为报错中断代码执行      | 无法获取操作结果                     |
| receiver   | 参数 `receiver` 可以指定 `this` 指向        | 不能                                 |

### 应用

我们可以使用 `Reflect` 实现一个最简单的观察者模式。

观察者模式指得是函数自动观察数据对象，一旦对象变化，函数就会自动执行。

```js
const person = observerable({
  name: 'Zhange San',
  age: 47,
});

function print() {
  console.log(`${person.name}, ${person.age}`);
}

observe(print);

person.name = 'Li Si';
// 放回目标结果：
// Li Si, 47

const observe = (fn) => {   
    // 待实现
    // ....
};

const observable = (obj) => {
    // 待实现
    // ...
};
```

上面代码中，`person` 是观察对象，函数` print` 是观察者，一旦数据发生变化，`print` 就会自动执行。我们需要实现观察者模式，即实现 `observe` 和 `observable`函数。

下面，我们用` queuedObservers `存放观察者们，`observable `用于代理目标对象，监听并拦截 `set `方法，一旦目标对象发生变化，则依次调用观察者们 `queuedObservers` 中的函数。

```js
// 创建观察者队列
const queuedObservers = new Set();
// 添加观察对象时需要执行的函数
const observe = (fn) => queuedObservers.add(fn);
// 监听对象
const observable = (obj) => new Proxy(obj, { set });
// 监听对象的 set 操作
function set(target, key, value, receiver) {
	// 设置对象属性的值
	const result = Reflect.set(target, key, value, receiver);
	// 观察对象改变时，执行添加的函数
	queuedObservers.forEach((observer) => observer());
	return result;
}
```

完整代码如下：

```js
// 创建观察者队列
const queuedObservers = new Set();
// 添加观察对象时需要执行的函数
const observe = (fn) => queuedObservers.add(fn);
// 监听对象
const observable = (obj) => new Proxy(obj, { set });
// 监听对象的 set 操作
function set(target, key, value, receiver) {
	// 设置对象属性的值
	const result = Reflect.set(target, key, value, receiver);
	// 观察对象改变时，执行添加的函数
	queuedObservers.forEach((observer) => observer());
	return result;
}

const person = observable({
	name: "Zhange San",
	age: 47
});

function print() {
	console.log(`${person.name}, ${person.age}`);
}

observe(print);

person.name = "Li Si";
// Li Si, 47
```

# 第九章  JavaScript运行时

## 谈谈对执行上下文的理解？

面试高频指数：★★★☆☆

### JavaScript 执行上下文

当一段 JavaScript 代码在运行的时候，它实际上是运行在执行上下文中。下面 3 种类型的代码会创建一个新的执行上下文：

* **全局执行上下文**：只有一个，为存在于 `JavaScript` 函数之外的任何代码而创建，浏览器中的全局对象就是 `window` 对象。
* **函数执行上下文**：存在无数个，函数调用时创建。这个上下文就是通常说的“本地上下文”。
* **`eval` 函数**： 指的是运行在 `eval `函数中的代码，很少用而且不建议使用。

每一个上下文在本质上都是一种作用域层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。JavaScript 引擎通过创建**执行上下文栈**（Execution Context Stack，ECS） 管理执行上下文。

### 创建阶段和执行阶段

当我们调用一个函数时，一个新的执行上下文就会被创建。一个执行上下文可分为创建阶段和执行阶段。我们用下面的代码分析一下两个过程：

```js
let x = 10;

function timesTen(a){
    return a * 10;
}

let y = timesTen(x);

console.log(y); // 100
```

#### 创建阶段

当 JavaScript 引擎第一次执行代码时，它会创建全局执行上下文，在创建阶段会进行以下操作：

* 创建全局对象，如浏览器中的 window， Node.js 中的 global（第一次）
* 创建变量和函数，使用 undefined 作为变量的初始值
* 确定 this 对象指向，第一次执行代码 this 绑定在全局对象上。
* **确定作用域链**

如果 JavaScript 引擎执行上面的代码：

* 首先，在全局执行上下文中存储变量 `x` 和 `y`， 以及函数声明 `timesTen`

* 使用 `undefined` 作为变量 `x` 和 `y` 的初始值

  <img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode09.png" alt="s" style="zoom:50%;" />

#### 执行阶段

代码执行阶段进行以下操作：

* **变量赋值**
* **函数引用**
* **执行其他代码**

函数经过创建阶段和执行阶段，并在执行后返回结果。

如下面图所示：

<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode10.png" style="zoom:50%;" />

<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode11.png" style="zoom:50%;" />

## 简单介绍一下垃圾回收机制

面试高频指数：★★★☆☆

垃圾回收是删除任何其他对象未使用的对象的过程。垃圾收集通常缩写为 "GC"。它是内存生命周期的一部分：

内存生命周期分为：

- 分配需要的内存
- 使用分配到的内存（读、写）
- 不需要时将其释放

垃圾回收需要去寻找内存“不需要”的对象，这里涉及到引用概念。我们也可以简单理解为“链接”。一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。

### 引用计数垃圾回收

这是最初级的垃圾收集算法，只判断“对象有没有其他对象引用到它”。如果没有，对象就会被垃圾回收机制回收。

```js
// 创建两个对象，一个变量 o1 和另一个被引用的属性 a
let o1 = {
    a: {
        b: 2
    }
};

let o2 = o1; // o2 是 o1 的引用
```

如下图：

<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode12.png" style="zoom:50%;" />

我们执行下面代码后：

```js
o2 = 1; 
o1 = null; // 可以被垃圾回收了
```

<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode13.png" style="zoom:50%;" />

### 限制：循环引用

引用计数垃圾回收无法处理循环引用的问题。因为对象始终互相应用，形成循环，无法被回收。

```js
function f() {
	var o1 = {};
	var o2 = {};
	o1.a = o2; // o1 的属性 a 引用 o2
	o2.a = o1; // o2 的属性 a 引用 o1
	return "azerty";
}
f();
```

<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode14.png" style="zoom:50%;" />

### 标记清除算法

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。算法假定设置一个叫做根的对象，从根开始，找对象的引用，以此类推。循环引用的问题也得以解决。

整个标记清除算法大致过程就像下面这样:

* 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
* 从各个根对象开始遍历，把不是垃圾的节点改成 1
* 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
* 把所有内存中对象标记修改为 0，等待下一轮垃圾回收

除此之外，JavaScript 引擎还有一些优化处理：

> * 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。
> * 增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。
> * 闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

## 如何判断当前脚本运行在浏览器还是 Node 环境中？

面试高频指数：★★★☆☆

在浏览器中，顶级作用域是全局作用域，即可以使用 var 定义一个全局变量。然而 Node.js 却不一样，它的顶级作用域不是全局作用域，var 声明的变量也是该模块的局部变量

```js
var foo = "foobar";
foo === window.foo; // true
```

`Object.prototype.toString.call()` 可以用于判断当前脚本运行的环境：

```js
Object.prototype.toString.call(window); // "[object Window]"
```

```js
Object.prototype.toString.call(global); // "[object global]"
```

因此，我们如下判断：
```js
let isBrowser = typeof window !== "undefined" && ({}).toString.call(window) === "[object Window]";

let isNode = typeof global !== "undefined" && ({}).toString.call(global) == "[object global]";
```

## JavaScript 事件循环是什么？

面试高频指数：★★★★☆

### JavaScript 是单线程

JavaScript 是单线程编程语言，意味着它一个时间点只能做一件事情，即“一心不可二用”。

JavaScript 引擎执行代码时，从文件的上面开始，到文件结束为止。它创建执行上下文、解析、在执行阶段将函数压入和弹出调用栈等。

如果函数花费太长时间执行，浏览器页面就会“卡死”。这对用户来说体验太糟糕了。我们可以模拟一个执行时间略长的函数：

```js
function task(message) {
    // 模拟一段长时间
    let n = 10000000000;
    while (n > 0){
        n--;
    }
    console.log(message);
}

console.log("Start script..."); // "Start script.."
task("Call an API"); // "Call an API"
console.log("Done!"); // "Done"
```

`task` 函数要遍历结束后，才会继续执行下面的 `console.log("Done!")`。

### 事件循环

我们可以将需要长时间执行的代码放到回调函数稍后执行。

```js
console.log("Start script...");

setTimeout(() => {
    task("Download a file.");
}, 1000);

console.log("Done!");

// Start script...
// Done!
// Download a file.
```

之前提到 JavaScript 是单线程的，然而更准确的说，JavaScript 运行时一次只能做一件事情。

当我们调用 `setTimeout()` 时，或者向服务器发送一个请求，或者触发 DOM 事件，都是浏览器中 Web API 的一部分。

在我们上面的例子里，调用 `setTimeout()` 时， Web API 创建一个 1 秒后过期的定时器.
<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode15.png" style="zoom:50%;" />

定时器到时间后，JavaScript 引擎将 `task` 放到的任务队列里面

<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode16.png" style="zoom:50%;" />

更详细的事件循环如下：

* 从 **宏任务** 队列中出队并执行最早的任务，宏任务有：
  - `script`
  - `DOM` 事件，如 `mousemove`
  - `setTimeout`
  - `setInterval`
* 执行所有 **微任务**：当微任务队列非空时，出队（dequeue）并执行最早的微任务。微任务有：
  * `queueMicrotask(f)`
  * `promise`

- 如果有变更，则将变更渲染（`render`）出来。
- 如果宏任务队列为空，则休眠直到出现宏任务。
- 转到步骤 1。
  <img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode17.png" style="zoom:50%;" />

### 小练习

给出下面代码的输出顺序：

```js
console.log(1);

setTimeout(() => {
	console.log(2);
}, 0);

let promise = new Promise((resolve) => {
	console.log(3);
	resolve();
})
	.then((res) => {
		console.log(4);
	})
	.then((res) => {
		console.log(5);
	});

console.log(6);
```

答案： 依次输出 1 3 6 4 5 2。按照顺序执行代码：

* 遇到 console.log 打印 1
* setTimeout 是 Web API，设置定时器，时间到后加入调用队列中
* new Promise() 中传递的函数立即执行，因此打印 3
* .then() 调用都加入任务队列
* 遇到 console.log 打印 6
* 查看任务队列，有两个 Promise 创建的微任务，依次打印。
* setTimeout 的任务加入任务队列。最后执行打印 2。

## JavaScript 中内存泄漏有哪几种情况？

面试高频指数：★★★☆☆

内存泄漏指申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄漏过多的话，就会导致后面的进程申请不到内存。因此内存泄漏会导致内部内存溢出。

一般是堆区内存泄漏，栈区不会泄漏。JavaScript 原始数据类型的值保存在栈中，引用数据类型保存在堆中。所以对象、数组等才会发生内存泄漏。

常见的内存泄漏的原因：

- 隐式全局变量
- 没有被清除的定时器
- 游离 `DOM` 的引用
- 闭包

我们可以使用下面的方式进行调试：
打开 Chrome 浏览器 -> `More Tools` -> `Developer Tools` -> `Performance/Memory`，一般先在 `Performance` 面板录制页面内存占用情况随时间变化的图像，对内存泄漏有个直观的判断，然后在 Memory 面板定位问题发生的位置。

### 1.隐式全局变量

这些场景可能存在内存泄漏隐患：
```js
function foo(arg) {
	bar = "this is a hidden global variable";
}
```

`bar` 被添加到 `window` 对象上了，如果 `bar` 指向一个巨大的对象或 `DOM` 节点，那就是安全隐患。

### 2.没有被清除的定时器

```js
function getData() {
	return "Hello World!";
}

var someResource = getData();
setInterval(function () {
	var node = document.getElementById("Node");
	if (node) {
		node.innerHTML = JSON.stringify(someResource);
	}
}, 1000);
```

如果后续 `id` 为 `Node` 的节点被移除了，定时器里的 `Node` 变量仍然持有其引用，导致游离的 `DOM` 子树无法释放。

### 3.游离DOM的引用

```js
var elements = {
	button: document.getElementById("button")
};
function doStuff() {
	button.click();
}
function removeButton() {
	// button 是 body 的子节点.
	document.body.removeChild(document.getElementById("button"));
	// 因为 elements 对象中缓存了 DOM 节点引用，这里我们始终有对 id 是 button 的引用
}
```

### 4.闭包

```js
var theThing = null;
var replaceThing = function () {
	var originalThing = theThing;
	var unused = function () {
		if (originalThing) console.log("hi");
	};
	theThing = {
		longStr: new Array(1000000).join("*"),
		someMethod: function () {
			console.log(someMessage);
		}
	};
};
setInterval(replaceThing, 1000);
```

定义在 `replaceThing `里的函数都实际使用了` originalThing`，那就有必要保证让它们都取到同样的对象，即使`originalThing `被一遍遍地重新赋值，所以这些（定义在 `replaceThing `里的）函数都共享相同的词法环境。

只要变量被任何一个闭包使用了，就会被添到词法环境中，被该作用域下所有闭包共享。这是闭包引发内存泄漏的关键。

我们可以打开浏览器的开发者工具查看内存数据，选择如下图所示：
<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode18.png" style="zoom:30%;" />

点击 Start 按钮后：

<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode19.png" style="zoom:50%;" />

图中有两列：

- Shallow Size：指的是对象本身的内存大小。
- Retained Size：指的是在删除对象本身及其从 GC 根无法访问的依赖对象后释放的内存大小。

可以看到图中蓝色的条均匀分布，这些蓝色条代表新的内存分配。这些新的内存分配是内存泄漏的候选对象，需要重点关注。除此之外，还可以通过对比内存变化等手段查出具体内存泄漏的原因。

## JavaScript 的本地存储有哪些方式？

javaScript 本地存储的方法我们主要讲述以下四种：

- `cookie`
- `localStorage`
- `sessionStorage`
- `indexedDB`

### `cookie`

`cookie `指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP 无状态导致的问题。

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制` cookie` 有效期、安全性、使用范围的可选属性组成。
### `localStorage`

> 一个可被用于访问当前源的本地存储空间的 Storage 对象

可以进行以下操作：
```js
// 增加数据
localStorage.setItem('myCat', 'Tom');
// 读取数据
let cat = localStorage.getItem('myCat');
// 移除单个数据
localStorage.removeItem('myCat');
// 移除所有数据
localStorage.clear();
```

`localStorage` 有两个缺点：

- 无法像 `Cookie` 一样设置过期时间
- 只能存入字符串，无法直接存对象

### `sessionStorage`

`sessionStorage` 和 `localStorage` 使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，`sessionStorage` 将会删除数据。

### `indexedDB`

MDN 对其的定义如下：

> `indexedDB` 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。

优点：

* 储存量理论上没有上限
* 所有操作都是异步的，相比 localStorage 同步操作性能更高，尤其是数据量较大时
* 原生支持储存 JavaScript 的对象
* 是个正经的数据库，意味着数据库能干的事它都能干

缺点：

- 操作非常繁琐
- 本身有一定门槛

### 应用

在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：

* 标记用户与跟踪用户行为的情况，推荐使用` cookie`
* 适合长期保存在本地的数据（令牌），推荐使用` localStorage`
* 敏感账号一次性登录，推荐使用 `sessionStorage`
* 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用 `indexedDB`

# 第十章 应用

## 如何实现大文件上传？

面试高频指数：★★★★☆

如果我们想要实现大文件上传，最简单的思路就是把大文件切成小文件，然后确保小文件都上传给后端，后端再把小文件拼装起来。具体到每个步骤，我们都需要保证结果的正确性并考虑性能。

大文件上传步骤如下：

- 读取文件
- 文件切片
- 上传文件

我们分别讲解各个实现步骤：

### 1. 读取文件

我们先用 `HTML` 实现一个简单的文件上传界面：

`HTML` 代码如下：

```html
<input type="file" id="input" />
<button id="upload">上传</button>
```

我们接下来需要实现读取文件：

```js
let input = document.getElementById("input");
let upload = document.getElementById("upload");
// 创建一个文件对象
let files = {};

// 读取文件
input.addEventListener("change", (e) => {
	files = e.target.files[0];
});
```

### 2. 文件切片

文件信息包含文件的名字、大小、文件类型等信息。`File` 对象部分属性如下图：

| 属性                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `File.name`         | 返回文件名称                                                 |
| `File.size`         | 返回文件的大小。                                             |
| `File.type`         | 返回文件类型（MIME）                                         |
| `File.lastModified` | 返回当前 File 对象所引用文件最后修改时间，自 UNIX 时间起始值（1970 年 1 月 1 日 00:00:00 UTC）以来的毫秒数。 |

接下来创建切片：

```js
function createChunk(file, size = 1 * 1024 * 1024) {
	// A
	const chunkList = [];
	let cur = 0;
	while (cur < file.size) {
		chunkList.push({
			file: file.slice(cur, cur + size) // B
		});
		cur += size;
	}
	return chunkList;
}
```

上面的代码中：

- A 处：
  - `file` 是获取到的大文件
  - `size` 这里我们设置每个小切片的大小为 `1 * 1024 * 1024`

- B 处：`slice()` 方法帮助我们将大文件切成多个小文件

我们把大文件按照每个 1 * 1024 * 1024 大小进行切割，调用 `createChunk(files)` 后， 切割好的小文件列表就可以上传到服务器上了。

如果需要优化，可以将计算部分使用 `Web Worker` 计算。

### 3. 上传文件

我们点击“上传”按钮之后，将文件上传到服务器。我们先给按钮添加事件：

```js
upload.addEventListener("click", () => {
	const uploadList = chunkList.map(({ file }, index) => ({
		file,
		size: file.size,
		chunkName: `${files.name}-${index}`,
		fileName: files.name,
		index
	}));
	uploadFile(uploadList);
});
```

接下来，我们就需要实现` uploadFile()` 函数。我们需要把文件切片列表变成 `FormData`。`FormData `表示表单数据的键值对，我们将切片使用这种格式上传到服务器。创建表单类型数据：

```js
list.map(({ file, fileName, index, chunkName }) => {
    const formData = new FormData();
    formData.append("file", file); 
    formData.append("fileName", fileName); 
    formData.append("chunkName", chunkName); 
    return { formData, index };
})
```

发送上传文件请求，此处我们需要使用` Promise.all `来获取发送结果状态，如果每个请求都成功了将返回一个数组，如果其中一个抛出错误，将立即抛出错误。我们封装一个 `uploadFile` 函数：

```js
async function uploadFile(list) {
	const requestList = list
		.map(({ file, fileName, index, chunkName }) => {
			const formData = new FormData(); 
			formData.append("file", file); 
			formData.append("fileName", fileName); 
			formData.append("chunkName", chunkName); 
			return { formData, index };
		})
		.map(({ formData, index }) =>
			fetch(url, {
				method: "POST",
				body: formData
			}).then((res) => {
				console.log(res)
			})
		);
	await Promise.all(requestList); 
}
```

### 完整代码

`HTML` 部分：

```html
<input type="file" id="input">
<button id="upload">上传</button>
```

`JavaScript`部分:

```js
let input = document.getElementById("input");
let upload = document.getElementById("upload");
let files = {};
let chunkList = [];

// 1. 读取文件
input.addEventListener("change", (e) => {
	files = e.target.files[0];
	chunkList = createChunk(files);
});

// 2. 创建切片
function createChunk(file, size = 1 * 1024 * 1024) {
	const chunkList = [];
	let cur = 0;
	while (cur < file.size) {
		chunkList.push({
			file: file.slice(cur, cur + size)
		});
		cur += size;
	}

	console.log("chunkList", chunkList);
	return chunkList;
}

// 3.文件上传

async function uploadFile(list) {
	const requestList = list
		.map(({ file, fileName, index, chunkName }) => {
			const formData = new FormData();
			formData.append("file", file);
			formData.append("fileName", fileName);
			formData.append("chunkName", chunkName);
			return { formData, index };
		})
		.map(({ formData, index }) =>
			// url 为请求地址
			fetch(url, {
				method: "POST",
				body: formData
			}).then((res) => {
				console.log(res); 
			})
		);
	await Promise.all(requestList); 
}

upload.addEventListener("click", () => {
	const uploadList = chunkList.map(({ file }, index) => ({
		file,
		size: file.size,
		percent: 0,
		chunkName: `${files.name}-${index}`,
		fileName: files.name,
		index
	}));
	uploadFile(uploadList);
});
```

## 如何实现树形结构列表和扁平列表的互相转换？

面试高频指数：★★★★☆

要实现两者的互相转换，我们先看一下两者的结构。扁平的数据内容如下：
```js
const flat = [
    { id: 1, name: "部门1", pid: 0 },
    { id: 2, name: "部门2", pid: 1 },
    { id: 3, name: "部门3", pid: 1 },
    { id: 4, name: "部门4", pid: 3 },
    { id: 5, name: "部门5", pid: 4 }
]
```

数状结构：

```js
const tree = [
    {
        id: 1,
        name: "部门1",
        pid: 0,
        children: [
            {
                id: 2,
                name: "部门2",
                pid: 1,
                children: []
            },
            {
                id: 3,
                name: "部门3",
                pid: 1,
                children: [
                    {
                        id: 4,
                        name: "部门4",
                        pid: 3,
                        children: [
                            {
                                id: 5,
                                name: "部门5",
                                pid: 4,
                                children: []
                            }
                        ]
                    }
                ]
            }
        ]
    }
];
```

### 扁平结构转树状结构

观察两者的结构后，从扁平结构转树状结构需要做以下事情：

- 树形结构按照 `pid` 的大小重新排列， `pid` 为 `0` 的是根，包含其他所有项目
- 新增 `children` 属性
  - 同一个 `pid` 的项目都放在 `children` 数组中
  - 如果 `pid` 下无项目，则 `children` 为空

接下来，我们就来实现这个数状结构。主要步骤如下：

* 遍历 flatList，把数据转成 Map 结构，方便查找
* 同时，直接从 Map 中查找相同的 pid 项目，放在同一层 children 中
* 处理根节点和非根节点的情况

```js
const flatToTree = (list) => {
    const result = [];
    const itemMap = {};
    // 遍历
    list.forEach((item) => {
        const { id, pid } = item;
        // children 不存在则添加 children
        if (!itemMap[id]?.children) {
            itemMap[id] = {
                children: []
            };
        }  
        // 从 `Map` 中查找相同的 `pid` 项目，放在同一层 `children` 中
        itemMap[id] = {
            ...item,
            children: itemMap[id]["children"]
        };

        const treeItem = itemMap[id];
        // 判断是不是根
        if (pid === 0) {
            result.push(treeItem);
        } else {
            if (!itemMap[pid]?.children) {
                itemMap[pid] = {
                    children: []
                };
            }
            itemMap[pid]["children"].push(treeItem);
        }
    });
    return result;
};

flatToTree(flat);
```

### 树状结构转扁平结构

树状结构转扁平结构只需要按照 `id` 排列即可，同时删除 `children` 属性。步骤如下：

* 创建一个数组 queue，将 data 存入，首次遍历的时候只有一个元素，即根节点(pid 为 0)
* 从数组 queue 头部取出元素，判断有无 children 属性
  * 有 children，再次添加到 queue 的尾部，并删除 children

```js
const treeToFlat = (data) => {
    const result = [];
    const queue = [...data];
    // 遍历
    while (queue.length) {
        // 从数组头部取出数据
        const node = queue.shift();
        const children = node.children;
        // 如果有 children， 继续添加到 queue 中
        if (children) {
            queue.push(...children);
        }
        // 删除 children 属性
        delete node.children;
        // 将处理好的节点添加到 result 中
        result.push(node);
    }
    return result;
};

treeToFlat(tree);
```

## 什么是单点登录？

面试高频指数：★★★☆☆

单点登录（Single Sign On，简称 SSO）简单来说就是用户只需在一处登录，不用在其他多系统环境下重复登录。用户的一次登录就能得到其他所有系统的信任。

### 为什么需要单点登录

单点登录在大型网站应用频繁，比如阿里旗下有淘宝、天猫等，用户的一次操作或交易就可能涉及到其他众多子系统的协作。使用单点登录就可以让用户登录一次，免去频繁登录授权的苦恼。

### 早期的单系统登录

用户在登录界面输入自己的用户名和密码之后，浏览器向服务器发送登录请求，服务器验证通过用户信息后放入 session，并将 sessionId 放入 Cookie，随后返回给浏览器。登录过后的请求都将在 Cookie 中携带 sessionId，服务器通过 sessionId 获取用户信息，最后返回响应信息。

### 单点登录的实现方式

如果一处登录的 session 能够共享，那么多个应用系统之间的登录状态也可以共享了。所以单点登录的关键在于，如何让 sessionId （或 Token）在多个域中共享。

### 同域下的单点登录

一个企业一般情况下只有一个域名，子系统使用二级域名。比如百度搜索是一级域名：https://www.baidu.com，贴吧使用的是二级域名https://tieba.baidu.com。如果我们要实现单点登录，可以将 Cookie 的域设置为顶域，即 https://www.baidu.com，这样其余的子域系统都可以访问顶域的 Cookie 了。

当然，上面做法缺点也很明显，它不支持跨域。这还不是真正的单点登录。

### 不同域下的单点登录

要实现不同域下的单点登录， 我们需要一个 SSO 认证中心来专门处理登录请求。所有的请求（登录、退出、获取用户信息、当前用户状态）都请求 SSO 系统，SSO 系统维护用户信息。流程如下：
<img src="https://maostudy.oss-cn-hangzhou.aliyuncs.com/image/leecode20.png" style="zoom:100%;" />

首次登录时：

* 用户登录某应用网站，浏览器将用户的登录重定向到 SSO 认证中心
* SSO 进行检查和校验是否有现有的 SSO Cookie
* 由于首次登录，并且用户浏览器不存在 SSO Cookie，因此请求用户使用 SSO 配置的连接登录。
* 用户登录后，将设置 SSO Cookie，用户将被重定向到应用程序，并使用包含用户相关的身份信息的令牌（Token）

后续登录中：

* 应用网站将用户重定向到 SSO 认证中心
* SSO 认证中心 检查是否存在现有的 SSO Cookie
* SSO 认证中心验证 SSO Cookie 是否有效
  * 无效，用户被重定向到应用网站的登录页面
  * 有效，用户将被重定向到应用程序，并带有包含用户相关身份信息的令牌（Token）。

其实，SSO 认证中心相当于一个登录中介，它统一管理用户在多系统下的登录操作。

使用 SSO 的好处就是简化登录流程，用户友好且安全。

## Web 常见的攻击方式有哪些？

面试高频指数：★★★★☆

常见的 Web 攻击方式有以下几种：

- 跨站脚本攻击（XSS 攻击）
- 跨站请求伪造（XSRF 攻击）
- SQL 注入

### XSS 攻击

MDN 定义如下：

> 跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。若受害者运行这些恶意代码，攻击者就可以突破网站的访问限制并冒充受害者。
>

简单来说，跨站脚本攻击利用恶意脚本发起攻击，通常这些恶意脚本可以任意读取 cookie、session tokens，或其他敏感网站信息。以下两种情况容易发生 XSS 攻击：

- 从一个不可靠的链接进入到一个 Web 应用程序。
- 没有过滤掉恶意代码的动态内容被发送给 Web 用户。

如果要过滤恶意代码，提交给后端，就能尽可能避免此类攻击。

DOM 中的内联事件监听器，如 `location`、`onclick` 等，`<a>` 标签的 `href` 属性，JavaScript 的` eval()`、`setTimeout()`、`setInterval() `等，都能把字符串作为代码运行。

如果用` Vue/React` 技术栈，并且不使用 `v-html/dangerouslySetInnerHTML` 功能，就能在前端 `render` 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。

### XSRF 攻击

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。

如果你登录了 bank.com 网站，此时，你有了来自该网站的身份验证 cookie。浏览器将会在你的每次请求上带上 cookie，以便识别你，执行所有的敏感财务操作。

当你在另一个窗口中浏览网页时，不小心访问了一个` eval.com` 的网站，该网站有一段提交表单的 JavaScript 代码：` <form action="https://bank.com/pay">`，它含有交易字段。这时候，提交表单请求虽然由 eval.com 发起，当它携带了` bank.com `的` cookie`，因此验证通过，攻击就完成了。

那么我们怎么预防呢？方案有：

- 阻止不明外域的访问
  - 同源检测
  - Samesite cookie
- 提交时要求附加本域才能获取的信息
  - CSRF Token
  - 双重 cookie 验证

### SQL 注入

SQL 注入攻击，是通过将恶意的 SQL 查询或添加语句插入到应用的输入参数中，再在后台 SQL 服务器上解析执行进行的攻击。比如，后端使用 SQL 查询时，篡改的查询参数或其他 SQL 代码，就会造成 SQL 注入攻击。

可以使用预编译方式或者 ORM 框架避免此类攻击发生。

# 补充

## ES6新特性

ES6（ECMAScript 2015）引入了许多新特性和语法改进，下面列举一些主要的ES6新特性：

1. **块级作用域**和`let`、`const`关键字：引入`let`和`const`关键字，用于声明块级作用域的变量和常量。
2. **箭头函数**：使用箭头（`=>`）语法定义函数，简化了函数的声明和使用，并自动绑定了函数的上下文。
3. **模板字面量**：使用反引号（``）包裹字符串，支持插值表达式和多行字符串，提供了更方便和可读性更好的字符串拼接方式。
4. **解构赋值**：通过解构模式，可以从数组或对象中提取值并赋给变量，实现快速、便捷的变量赋值。
5. **默认参数值**：在函数参数中可以指定默认值，当调用函数时未提供对应参数的值时，将使用默认值。
6. **扩展运算符**和**剩余参数**：使用`...`运算符可以将数组或对象展开为独立的元素，也可以将多个参数合并为数组。
7. **类和模块化**：引入了类（`class`）的概念，提供了面向对象编程的语法糖。同时，通过`import`和`export`关键字支持模块化开发，方便组织和管理代码。
8. **箭头函数**：使用箭头（`=>`）语法定义函数，简化了函数的声明和使用，并自动绑定了函数的上下文。
9. **Promise**和异步编程：引入了Promise对象，提供了更优雅和可靠的异步编程解决方案，避免了回调地狱。
10. **迭代器**和**生成器**：通过迭代器（Iterator）和生成器（Generator）支持更灵活和可控的迭代和异步编程模式。
11. **新的数据类型**和**数据结构**：引入了`Map`、`Set`、`Symbol`等新的数据类型和数据结构，提供了更多的数据处理和存储选项。

这只是ES6引入的一些主要特性，还有其他一些语法改进和新增的功能。ES6的引入大大增强了JavaScript的表达能力和开发效率，使得开发者可以更优雅地编写现代化的JavaScript代码。

## 对于单页面应用，通过点击tab切换页面时的整个流程是怎样的

1. 用户点击页面上的一个 tab 标签或导航链接。
2. JavaScript 捕捉到点击事件，触发路由切换事件。
3. 根据点击的 tab 或链接，单页面应用的路由系统会解析对应的路径或标识符。
4. 路由实例会根据当前 URL 的路径匹配路由配置，找到对应的组件，并渲染到指定的位置，从而实现视图的动态切换。
5. 如果有必要，路由系统可能会触发一些异步操作，如加载数据或执行预处理逻辑。
6. 路由系统将找到的组件或视图渲染到页面的合适位置，通常是一个指定的容器。
7. 渲染完成后，用户在浏览器中看到新的内容，呈现为切换后的页面。
8. 如果需要，SPA 可能会更新浏览器的 URL 地址，以便用户可以直接访问切换后的页面。
9. 页面切换完成后，SPA 可能会执行一些附加的操作，如更新页面标题、执行动画效果或触发一些其他的逻辑。

## 防抖与节流

**防抖**：基本原理是，在事件触发后，等待一段时间（等待期）后执行函数。如果在等待期内再次触发了该事件，则重新计时等待期，常用于实时搜索。

**节流**：基本原理是，在一定的时间间隔内只执行一次函数。当事件触发后，函数会立即执行，并在指定的时间间隔内忽略后续的事件触发。

## 跨域问题

跨域（Cross-Origin）指的是在浏览器中，当一个网页的 JavaScript 代码试图访问另一个域（域名、端口或协议不同）下的资源时，就会发生跨域。浏览器的同源策略限制了跨域访问，以保护用户的安全和隐私。

解决跨域问题的方法：

1. **使用服务器端代理**：可以在服务器端创建代理接口，将跨域请求发给服务器，然后由服务器代为请求目标资源，然后再将请求结果返回给客户端
2. `JSONP`：利用`<script>`标签可以跨域加载资源的特性来解决跨域问题。通过在客户端动态创建`<script>`标签，将需要获取的数据作为参数传递给服务器端的一个回调函数，服务器端返回一个包裹在回调函数中的数据，客户端通过回调函数获取数据。
3. `CORS（跨域资源共享）`：CORS是一种现代浏览器支持的跨域解决方案，通过在服务器端设置响应头部信息来实现。服务器端在响应中添加特定的CORS头部（如`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`等），告诉浏览器允许来自其他域的请求访问资源。
4. `WebSocket`协议：WebSocket是一种全双工通信协议，与HTTP协议不同，它**建立在单个TCP连接上**，可以实现客户端和服务器之间的实时数据传输。由于WebSocket是通过HTTP协议建立连接，然后升级到WebSocket协议，因此它不受同源策略的限制。
5. `iframe`跨域通信：如果需要在不同域名的页面之间进行通信，可以利用iframe的特性来实现。通过在主页面中创建一个隐藏的iframe元素，并设置其src属性为另一个域名下的页面，通过在iframe之间进行数据传递，实现跨域通信。
